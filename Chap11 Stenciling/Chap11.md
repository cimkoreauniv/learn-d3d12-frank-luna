# 11. 스텐실

스텐실 버퍼는 특수 효과에 쓰이는 화면 밖 버퍼이며, 후면 버퍼 및 깊이 버퍼와 크기가 같으며 각 픽셀이 1대1 대응된다. 스텐실 버퍼를 지정하면 그 스텐실 버퍼는 깊이 버퍼에 부착된다.

스텐실은 미술에서 특정 부분을 가리고 물감을 뿌리면 가려진 부분은 물감이 칠해지지 않는 용법이다. 컴퓨터 그래픽에서도 마찬가지로 특정 픽셀 단편들이 후면 버퍼에 기록되지 못하도록 하는 역할을 한다.

스텐실 버퍼를 활용할 수 있는 대표적인 예시로 거울이 있다. 그래픽에서 거울을 구현할 때에는 거울에 비친 물체의 모습(반사상)을 표현하기 위해 동일한 물체를 거울의 반대편에 렌더링한다. 이때 반사상을 기존의 방식대로 렌더링하게 되면 반사상이 보이지 않아야 하는 위치에서도 반사상을 볼 수 있게 된다. 스텐실 버퍼를 이용하면 거울 영역 내에서만 반사상이 그려지도록 할 수 있다.

## 목표

1. 파이프라인 상태 객체의 D3D12_DEPTH_STENCIL_DESC 필드를 채워서 깊이/스텐실 버퍼 상태를 제어하는 방법을 파악한다.
2. 스텐실 버퍼로 거울면 바깥에 반사상이 그려지지 않게 해서 거울을 구현하는 방법을 배운다.
3. 이중 혼합이 무엇이고 스텐실 버퍼를 이용해서 이중 혼합을 방지하려면 어떻게 해야 하는지 살펴본다.
4. 깊이 복잡도를 이해하고, 장면의 깊이 복잡도를 측정하는 두 가지 방법을 알아본다.

## 11.1 깊이/스텐실 버퍼의 자료 형식과 버퍼 지우기

깊이/스텐실 버퍼는 하나의 텍스처이다. 그러므로 깊이/스텐실 버퍼를 생성하려면 특정한 자료 형식을 지정해야 한다.

이 책의 예제에서는 [0, 1] 구간을 나타내는 24비트 부동소수점 깊이 값 하나와 [0, 255] 구간을 나타내는 8비트 스텐실 값으로 구성되는 깊이/스텐실 버퍼 자료 형식을 사용한다.

스텐실 버퍼는 프레임의 시작에서 초기화해야 하는데, 그 메서드가 command list의ClearDepthStencilView이다. 이 메서드는 깊이 버퍼도 함께 지운다. 자세한 설명은 https://docs.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-cleardepthstencilview를 참고한다.

## 11.2 스텐실 판정

스텐실 버퍼를 이용하면 후면 버퍼의 일부 영역에 렌더링이 되지 않도록 막을 수 있다. 스텐실을 적용할 경우 한 픽셀이 후면 버퍼에 기록되는지 여부가 스텐실 판정(stencil test)에 의해 결정된다. 스텐실 판정의 식은 다음과 같다.

StencilRef & StencilReadMask ⊴ Value & StencilReadMask

StencilRef는 프로그램에서 전달하는 스텐실 기준값(stencil reference)이다. Value는 스텐실 버퍼의 해당 픽셀에 들어있는 값이다. 공통적으로 StencilReadMask와 비트 AND를 취한다. StencilReadMask의 비트가 0인 부분은 스텐실 판정에서 배제시킬 수 있다.

스텐실 판정의 결과는 선택한 비교 연산자(⊴)에 의해서 결정된다. ⊴에는 등호, 부등호, 항상 참, 항상 거짓 중 하나를 D3D12_COMPARISON_FUNC 열거형을 이용해 지정할 수 있다.

## 11.3 깊이/스텐실 상태의 서술

깊이/스텐실 상태는 D3D12_DEPTH_STENCIL_DESC 구조체를 통해 서술한다.

### 11.3.1 깊이 설정들

1. DepthEnable: true면 깊이 버퍼링을 활성화, false면 비활성화이다. 깊이 버퍼링을 비활성화하면 무조건 나중에 그린 픽셀 단편이 후면 버퍼의 최종 색상이 될 것이며, 깊이 버퍼의 갱신이 일어나지 않는다.
2. DepthWriteMask: ZERO 또는 ALL을 지정할 수 있는데, ZERO를 지정하면 깊이 버퍼 쓰기가 비활성화된다. ALL을 지정하면 깊이 판정을 통과한 픽셀의 깊이가 기록된다. 깊이 버퍼의 기록과 깊이 판정은 별개이다. 기록을 비활성화한다고 해서 항상 깊이 판정이 일어나지 않는 것은 아니다.
3. DepthFunc: 깊이 판정에 사용하는 비교 함수를 지정한다. 기본값은 LESS 함수이며, 이는 기존에 사용한 것과 같이 깊이 값이 작은, 즉 앞에 있는 물체가 깊이 판정을 통과하는 것이다. 필요하다면 다른 방식의 깊이 판정을 적용할 수 있다.

### 11.3.2 스텐실 설정들

1. StencilEnable: 스텐실 판정의 활성화 여부.
2. StencilReadMask: 11.2에서 언급한 변수이며, 이를 조작하면 특정 비트를 읽지 않을 수 있다. 기본값은 모두 읽는 것이다(0xff).
3. StencilWriteMask: 스텐실 버퍼를 갱신할 때 특정한 비트만을 선택하고 나머지는 제외시키는 값이다. 기본값은 0xff이다.
4. FrontFace: 전면 삼각형에 대한 스텐실 버퍼 적용 방식을 결정하는 구조체 변수.
5. BackFace: 후면 삼각형에 대한 스텐실 버퍼 적용 방식을 결정하는 구조체 변수.

FrontFace와 BackFace는 D3D12_DEPTH_STENCILOP_DESC 구조체이다. 여기의 멤버들은 다음과 같다.

1. D3D12_STENCIL_OP StencilFailOp: 스텐실 판정에 실패했을 때 적용할 연산.
2. D3D12_STENCIL_OP StencilDepthFailOp: 스텐실 판정은 성공, 깊이 판정 실패시 적용할 연산.
3. D3D12_STENCIL_OP StencilPassOp: 스텐실과 깊이 판정 모두 성공시 적용할 연산.
4. D3D12_COMPARISON_FUNC StencilFunc: 스텐실 판정 비교 연산자를 지정한다.
   D3D12_STENCIL_OP는 스텐실 버퍼에 어떤 변화를 가할지를 지정하는 열거형으로, API 문서(https://docs.microsoft.com/en-us/windows/win32/api/d3d12/ne-d3d12-d3d12_stencil_op)를 참고한다.

### 11.3.3 깊이/스텐실 상태의 생성 및 묵기

깊이/스텐실 상태 서술 구조체를 다 채웠다면 PSO의 DepthStencilState에 전달하면 된다.

스텐실 기준값을 설정하기 위해서는 command list의 OMSetStencilRef를 이용한다.

## 11.4 평면거울 구현

단원의 시작에서 언급한대로 반사상이 거울을 통해서만 보이도록 하기 위해 스텐실 버퍼를 활용할 것이다. 다음은 장면 전체를 렌더링하는 과정을 개괄적으로 표현한 것이다.

1. 바닥, 벽, 두개골을 평소대로 렌더링한다. 이 과정에서 스텐실 버퍼를 0으로 초기화한다.
2. 거울을 스텐실 버퍼에만 렌더링한다. 깊이 판정과 스텐실 판정 모두를 성공했을 때 기존 스텐실 항목을 1로 바꾸도록 설정한다. 나머지 경우(스텐실 실패, 스텐실 성공&깊이 실패)에는 스텐실 버퍼 값을 그대로 유지한다. 이렇게 하면 다른 물체들에 가리지 않는 거울의 부분들이 스텐실 버퍼에 기록되게 된다.
3. 반사상 두개골을 렌더링한다. 스텐실 버퍼의 값이 1인 부분들만 스텐실 판정을 통과하도록 설정한다. 이때 주의점은 반사상의 경우 원본을 뒤집는 식으로 구현하는데, 점들은 뒤집혔지만 감기는 순서는 뒤집히지 않았으므로 결과적으로 전면 삼각형과 후면 삼각형이 뒤바뀌게 된다. 그러므로 PSO에서 전면 삼각형을 반대로 해주어야 한다. 또한, 거울에 대칭을 시킨 반사상을 그릴 때 조명에도 대칭을 적용시켜야 한다.
4. 마지막으로 거울을 렌더링하면서 혼합을 적용하여 반투명한 거울을 그린다.

### StencilDemo의 여기까지의 구현 방법

해골에 입힐 텍스처는 1X1 흰색이다.

Pass 상수 버퍼를 하나 더 만들어 대칭시킨 조명의 위치를 저장한다.

PSO는 총 4개가 필요하다.

불투명 PSO(바닥, 원본 해골, 벽): opaque

투명 PSO(거울 자체를 렌더링할 때): transparent

스텐실 버퍼 기록용 PSO(거울을 스텐실 버퍼에만 렌더링, markStencilMirrors): 깊이 판정을 통과할 경우에 무조건 해당 위치를 1로 replace한다. 따라서 연산자는 always. 주의할 점은 깊이 판정은 하되 깊이 버퍼를 갱신하는 것은 막아야 하는 것이다. 그러므로 DepthMask를 ZERO로 세팅한다.

반사상 두개골 렌더링할 때 PSO(drawStencilReflections): 스텐실 버퍼가 1인 지점들만 스텐실 판정을 통과하도록 한다. 이를 위해 equal 연산자를 사용.

셰이더 코드는 모두 동일한 것을 사용한다.

## 11.5 평면 그림자의 구현

그림자 또한 하나의 렌더 항목으로 취급하며, 투명도가 50%인 검은색 물체로 혼합하면 된다.

### 11.5.1 평행광 그림자

책에 표시되어 있는 그림자 행렬은 원근 나누기를 하지 않은 좌표를 출력하는 행렬이다.

문제는 빛 벡터를 그대로 사용할 경우 그림자가 비추는 경우에는 법선과 빛 벡터가 이루는 각도가 90도가 넘으므로 내적 결과가 음수가 되며, 따라서 시야 공간 밖에 있다고 판단해 절단된다는 것이다. 여기서 빛 벡터의 부호를 뒤집어 사용할 경우(한 지점에서 광원을 향하는 벡터) n과 L을 내적한 결과의 부호가 뒤집히므로 잘 작동한다.

### 11.5.2 점광 그림자

점광의 위치를 L이라고 한다면 빛 벡터를 p-L로 정의할 수 있다.

### 11.5.3 범용 그림자 행렬

동차좌표(w)를 이용하면 점광(w=1)과 평행광(w=0) 모두에 적용하는 그림자 행렬을 만들 수 있다.

이 행렬은 XMMatrixShadow 함수를 통해 호출하면 된다.

### 11.5.4 스텐실 버퍼를 이용한 이중 혼합 방지

물체의 그림자를 그대로 렌더링할 경우 한 픽셀에 여러 개의 평면이 겹쳐 더 어두워질 수 있다. 이러면 곳곳에 더 어두운 얼룩들이 생기게 된다.

스텐실 버퍼를 이용하면 문제를 해결할 수 있다. 그림자가 렌더링된 부분은 스텐실 버퍼 값을 1로 바꾸는 것이다. 스텐실 버퍼가 0인 부분만 렌더링이 가능하게 하고 스텐실 판정을 통과했을 때 값을 증가시키도록 설정한다. 이를 통해 이중 혼합을 방지할 수 있다.

### 11.5.5 평면 그림자 구현 코드

그림자 재질은 그냥 50% 투명한 검은색 재질이다.

그림자를 위한 PSO를 추가로 설정한다.

추가적으로 그림자를 구현할 때 팁은 바닥으로부터 약간의 거리를 띄우는 것이다. 완전히 0으로 세팅해버리면 바닥의 픽셀들과 그림자의 픽셀들이 경쟁하여 해당 부분이 깜빡거리게 된다.

어차피 거울과 바닥이 겹치지 않고 바닥에만 그림자가 생기도록 할 것이므로 스텐실 버퍼를 초기화할 필요는 없다.
