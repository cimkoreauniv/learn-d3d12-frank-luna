# Chap12 기하 셰이더

기하 셰이더는 생략 가능한 단계이지만 테셀레이션 단계들을 사용할 경우에는 생략이 불가능하다. 기하 셰이더는 온전한 기본도형을 입력받아 기본도형들의 목록을 출력한다. 정점을 파괴하거나 생성할 수 없는 정점 셰이더와는 달리 기하 셰이더는 기하구조를 새로 생성하거나 파괴하는 것이 가능하다. 예를 들면 점 하나를 사각형 하나(삼각형 2개)로 확장하는 것이다. 기하 셰이더에서 출력하는 정점의 위치들은 동차 절단 공간으로 변환된 것이어야 한다.

## 목표

1. 기하 셰이더를 프로그래밍하는 방법을 배운다.
2. 기하 셰이더를 이용해서 빌보드를 효율적으로 구현하는 방법을 배운다.
3. 자동으로 생성되는 기본도형 ID들과 그 용도 몇 가지를 파악한다.
4. 텍스처 배열을 생성하고 사용하는 방법을 살펴보고, 텍스처 배열이 왜 유용한지 이해한다.
5. 알파-포괄도 변환이 알파 잘림의 앨리어싱 문제에 어떻게 도움이 되는지 이해한다.

## 12.1 기하 셰이더 프로그래밍

기하 셰이더의 주 함수 앞에 [maxvertexcount(N)] 형식으로 기하 셰이더가 출력 가능한 최대 정점 개수 특성(attribute)를 지정해야 한다. 이 숫자는 가능한 한 작게 설정하는 것이 성능에 좋다.

기하 셰이더는 기본적으로 두 개의 매개변수를 받는다. 하나는 입력 매개변수로, 기본도형을 정의하는 정점들의 배열이다. 원소는 기본 도형에 따라 달라지는데, 기본 도형이 점(point)이면 1개, 선(line)이면 2개, 삼각형(triangle)이면 3개, 인접성 정보를 담은 선(lineadj)이면 4개, 인접성 정보를 담은 삼각형(triangleadj)이면 6개이다.

출력 매개변수 앞에는 항상 inout 수정자를 붙여야 한다. 또한 출력 매개변수는 항상 스트림 형식이다. 여기에는 기하 셰이더가 출력하는 기본도형의 정점 목록을 저장해야 한다. 출력 스트림 목록에 Append 메서드를 이용해서 정점을 추가한다.

출력 스트림의 자료형으로는, PointStream, LineStream, TriangleStream의 3가지의 자료형을 사용할 수 있다. 담을 정점의 자료형을 템플릿(<>)으로 지정한다.

선과 삼각형의 경우 기본적으로 띠(Strip) 형태로 출력되며, 선 목록이나 삼각형 목록을 이용하고 싶다면 각 선 또는 삼각형 끝에서 RestartStrip 메서드를 사용하면 된다. 예를 들어 삼각형 목록을 출력하려면 정점 3개마다 RestartStrip을 호출해주면 된다.

540페이지와 541페이지에 보면 for문의 앞에 [unroll]이라는 속성이 붙어 있다. 이는 loop unrolling을 하라는 뜻으로, for문을 풀어서 컴파일하라는 의미이다. 예를 들어

for(int i=0; i<3; i++) f(i);를 unroll하면 f(0); f(1); f(2); 와 같이 되는 것이다. 따라서 상수 횟수만큼 수행되는 for문에 적용시킬 수 있다.

기하 셰이더를 컴파일하는 방법은 다른 셰이더들과 비슷하다.

기하 셰이더를 파이프라인에 묶는다.

## 12.2 나무 빌보드 예제

### 12.2.1 개요

멀리 떨어진 나무를 그릴 때에는 빌보드 기법이 효율적이다. 3차원 나무 구조를 직접 그리는 것이 아니라 사각형 평면에 나무의 2차원 텍스처를 그리는 것이다. 이 사각형을 빌보드라고 부른다. 멀리서 보면 빌보드와 3차원 구조를 구분하기 어렵다. 단, 항상 빌보드가 카메라를 향하도록 해야 한다.

빌보드의 국소 좌표계를 정의해보자. 위 방향은 (0, 1, 0)이며, 앞 방향은 (눈 좌표-카메라 좌표)의 xz성분이다. 오른쪽 방향은 위 벡터와 앞 벡터를 외적하여 구한다.

이번 장의 예제는 지면 약간 위쪽의 점들을 전달받는다. 위상 구조는 POINTLIST를 사용해야 한다. 각 점들을 빌보드의 중심으로 지정하여 기하 셰이더에서 사각형을 출력한다.

### 12.2.2 정점 구조체

정점 구조체에는 빌보드의 중심의 위치와 빌보드의 크기를 저장한다.

### 12.2.3 HLSL 파일

기하 셰이더에서는 정점 하나를 입력받아 삼각형 띠를 출력하며, 총 4개의 정점을 출력하여 사각형을 만든다. 사각형 띠를 만들 경우 삼각형 하나는 반시계방향으로 감기므로 빌보드를 그리는 PSO는 후면 선별을 꺼야 한다.

### 12.2.4 SV_PrimitiveID

이 semantic은 IA 단계에서 기본도형마다 ID를 부여한 것이다. 한 번에 n개의 기본도형을 그린다고 할 때 첫 번째는 0, 두 번째는 1, 마지막은 n-1이 부여된다. 이 ID는 하나의 그리기 호출에서 고유하게 쓰인다. 이 ID는 온전한 기하구조를 입력받는 기하 셰이더에서 사용 가능하며, 픽셀 셰이더에서 사용하고 싶다면 구조체를 통해 넘겨주면 된다.

참고: 정점 셰이더에서 SV_VertexID의 semantic을 가지는 정점 ID를 생성할 수도 있다.

## 12.3 텍스처 배열

### 12.3.1 개요

텍스처 배열은 텍스처들을 담은 배열이다. 표본을 추출할 때에는 3차원 좌표로 지정한다. 앞의 두 성분은 텍스처 좌표이며, 마지막 성분은 텍스처 배열의 한 텍스처를 선택하는 색인이다.
여기서는 (PrimitiveID % 텍스처 개수)를 인덱스로 지정하여 텍스처가 돌아가면서 적용되도록 한다.
텍스처 배열의 한 가지 장점은 한 번의 그리기 호출로 여러 개의 텍스처를 각각 입힐 수 있다는 것이다. 그렇지 않다면 그리기 호출을 여러 번 해야 할 것이다.

### 12.3.3 텍스처 배열의 적재

texassemble을 이용하면 여러 개의 텍스처를 배열로 만들 수 있다. 단, 각각의 텍스처의 밉맵 개수가 동일해야 한다. 밉맵을 적용하지 않은 텍스처들을 배열로 만든 다음에 texconv로 밉맵을 생성할 수도 있다.

### 12.3.4 텍스처 부분자원(subresource)

한 텍스처 배열에는 여러 장의 텍스처가 있고, 각 텍스처에는 여러 개의 밉맵이 있다. 텍스처 배열의 한 원소, 즉 하나의 밉맵 사슬을 텍스처 조각(texture slice)라고 하고 모든 텍스처에서 하나의 밉맵 수준을 모은 것을 밉 조각(mip slice)라고 부른다. 한 텍스처의 하나의 밉맵 수준을 부분자원이라고 부른다. D3D는 부분자원 각각에 선형 색인을 부여한다. 첫 번째 부분자원을 0으로 지정한 다음 1씩 증가할 때마다 밉맵 수준이 하나씩 증가하다가 밉맵 수준이 끝나면 다음 텍스처로 넘어가는 식이다.

## 12.4 알파-포괄도 변환

알파 포괄도 변환(alpha-to-coverage)이란 MSAA를 적용할 때 텍스처의 알파 채널까지 고려하는 것을 말한다. 이를 적용하면 더 매끄러운 가장자리를 만들어낼 수 있다.

MSAA는 폴리곤의 가장자리만을 샘플링하여 블렌딩하기 때문에, 빌보드의 텍스처에 대해서는 AA를 먹일 수 없다.

따라서 텍스처의 alpha 성분을 고려하여 샘플링을 하도록 하면 텍스처 이미지 자체의 가장자리를 반영할 수 있다.

다만, 이 방법을 적용하기 위해서는 텍스처를 거리 순으로 정렬하여 가까운 것부터 그려야 한다.
