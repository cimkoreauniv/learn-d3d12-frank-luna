# Chap8 조명

조명을 통해 3D 그래픽에서 입체감을 표현할 수 있다.
정확한 조명 모델을 사용할수록 계산 비용이 높아진다. 영화에서는 한 프레임에 할당할 수 있는 시간이 많기 때문에 매우 사실적인 조명 모델을 사용하지만 게임에서는 적어도 초당 30프레임 정도로는 렌더링해야 한다.
목표

1. 빛과 재질 사이의 기본적인 상호작용을 이해한다.
2. 국소(지역) 조명과 전역 조명의 차이를 이해한다.
3. 표면의 한 점이 면한 방향(facing, 법선 벡터)을 수학적으로 서술하는 방법과 그것을 이용해서 입사광이 표면을 때리는 각도를 구하는 방법을 파악한다.
4. 법선 벡터를 제대로 변환하는 방법을 배운다.
5. 주변광, 분산광, 반영광을 구분한다.
6. 지향광, 점광, 점적광을 구현하는 방법을 배운다.
7. 감쇠 매개변수들을 제어함으로써 빛의 세기를 깊이의 함수로서 변화시키는 방법을 이해한다.

## 8.1 빛과 재질의 상호작용

이전 예제들에서는 정점들의 색상을 직접 지정했지만, 조명을 사용할 때에는 현재 조명들과 재질을 고려하요 조명 방정식을 적용해서 정점 색상이 결정되게 한다. 결과적으로 물체의 색이 더 사실적으로 보인다.
재질(material)은 빛이 물체의 표면과 상호작용하는 방식을 결정하는 속성들의 집합이라고 할 수 있다. 그 예시로는 표면이 반사, 흡수하는 빛의 색상, 표면의 매끄러운 정도, 투명도 등이 있다. 재질 속성들을 적절히 지정하면 현실의 물체들을 흉내낼 수 있다.
하나의 광원은 R,G,B 빛을 여러 가지 세기로 방출한다. 이를 통해서 다양한 빛 색상을 흉내낼 수 있다. 빛은 여러 물체에 반사되거나 직접 관찰자의 눈에 도달해서 색이 보이게 된다.
하나의 재질은 RGB 각 빛을 일정한 비율로 반사한다. 하나의 빛이 적색광은 75%, 녹색광을 75%를 반사하고 나머지는 모두 흡수하는 식이다.
본 교재에서 사용할 조명 모델은 국소 조명 모델(local illumination model)이다. 국소 조명 모델은 빛과 물체만 고려하므로 빛과 물체 사이에 다른 물체가 있어 빛이 가로막히는지를 알 수 없다. 이에 반대되는 개념이 전역 조명 모형(global illumination(GI) model)이며, 다른 물체에서 반사된 간접광까지 고려한다. 이 방식은 일반적인 실시간 게임에 사용하기에는 너무 비용이 크다. GI를 구현하는 방법에는 레이 트레이싱, VXGI(voxel GI) 등이 있다. 한편, 정적 물체들에 대한 간접광을 미리 계산해두고 그것을 이용해서 동적 물체의 간접광을 근사하는 방법도 자주 쓰인다.

## 8.2 법선 벡터

표면의 한 점의 접평면(tangent plane)에 수직인 단위벡터이다.
조명 계산을 위해서는 메시의 모든 표면상의 점에서의 법선 벡터가 필요하다. 하지만 삼각형 위에서는 세 꼭짓점에서의 법선 벡터만 있다면 보간을 통해 다른 점들의 법선 벡터를 구할 수 있다.

### 8.2.1 법선 벡터의 계산

한 삼각형의 법선을 구하기 위해서는 삼각형의 두 변의 벡터를 구한 다음 외적을 하면 방향을 구할 수 있다.
미분이 가능한 표면이라면 미분을 이용해서 표면에 있는 점들의 법선을 구할 수 있다. 하지만 일반적으로 다각형 메시는 미분이 불가능하다. 삼각형 메시의 정점 법선들을 구할 때에는 흔히 정점 법선 평균 기법(vertex normal averaging)을 사용한다. 이 기법에서는 한 정점의 법선 벡터를 그 정점이 포함된 메시의 모든 삼각형의 면 법선의 평균으로 근사한다.

### 8.2.2 법선 벡터의 변환

점과 벡터들을 변환하는 변환행렬이 있을 때 법선 벡터가 평면과 수직이 되도록 유지하는 방법은 변환행렬의 역전치(inverse-transpose) 행렬을 곱하는 것이다.
본 교재에서 제공하는 라이브러리인 MathHelper에는 역전치행렬을 계산하는 함수가 있다. 이 함수는 이동 변환 부분을 (0, 0, 0)으로 처리한다. 그 이유는 이동 변환이 영벡터가 아닐 경우 역전치행렬의 마지막 열이 (0,0,0,1)이 아니게 되는데, 단독으로 쓰여 벡터를 변환시킬 때에는 큰 문제가 안되지만(벡터는 w=0이므로) 다른 변환 행렬과 결합했을 때가 문제가 될 수 있기 때문이다.

## 8.7 반영 조명

프레넬 효과(Fresnel effect)에 의해 발생하는 다른 종류의 반사가 있다. 굴절률(index of refraction)이 다른 두 물체 사이에 빛이 도달하면 빛의 일부는 반사되고 나머지는 굴절된다. 이런 종류의 빛 반사 과정을 반영 반사(specular reflection, 거울 반사)라고 하고 반사된 빛을 반영광(specular light)라고 한다.

굴절된 빛이 매질을 떠나서 눈에 들어오면 물체가 투명해보인다. 실시간 그래픽에서는 알파 혼합이나 후처리를 통해 투명 물체의 굴절을 근사하며, 구체적인 방법은 다른 장에서 설명한다. 여기서는 불투명한 물체만 고려한다.

반영 조명은 눈의 위치에 따라서 다르게 보이므로 시점 의존적이다.

### 8.7.1 프레넬 효과

입사광 중 반사되는 빛의 비율을 $R_f$라고 하면 굴절된 빛의 양은 $1-R_f$이다. 실제로 $R_f$는 3차원 색상이다.

반사된 빛의 양은 매질에 따라, 그리고 입사각에 따라서 달라진다. 입사각이 클수록(즉 비스듬히 입사할수록) 반사는 더 많이 발생하고 굴절은 조금 발생한다. 이 때 R_f를 계산하는 식이 프레넬 방정식이다. 완전한 프레넬 방정식은 복잡하므로 슐릭 근사(Schlick approximation)을 사용한다.

$R(\theta) = R_0 + (1 - R_0)(1-cos\theta)^5$

R_0는 입사각이 0도일 때의 색상인 동시에 재질의 한 속성(3차원 색상)이며, 비금속은 전체적으로 수치가 낮고, 금속들은 높다.

프레넬 효과의 예시로는 위에서 내려다볼 때에는 연못의 밑바닥이 잘 보이지만 옆에서 비스듬하게 볼 때에는 주변 환경이 반사된 모습이 잘 보이는 것이다.

### 8.7.2 표면 거칠기

한 평면의 법선을 거시 법선이라고 해보자. 이때 표면을 확대해보면 들쭉날쭉한 요철들이 있으며, 그 각각의 표면들의 법선들을 미시 법선이라고 하자. 완벽한 거울(매끈한 표면)은 입사된 빛을 전부 다 반사각의 방향으로 보내므로 미시 법선들이 모두 거시 법선과 일치한다고 할 수 있다. 표면이 거칠수록 미시 법선들이 거시 법선 방향에서 더 많이 벗어나게 된다.

표면 거칠기를 모델링하기 위해서 미세면(microfacet) 모형을 도입한다. 미세면 모형은 하나의 평면을 미세면이라고 칭하는 작은 평면 요소들의 집합으로 간주한다. 미세면 모형에서는 시점 벡터 v와 빛 벡터 L이 주어졌을 때 L을 v방향으로 반사하는, 즉 미시 법선 h = normalize(L + v)인 미세면들의 비율을 계산한다. 이 비율이 클수록 눈에 더 밝은 반영광이 도달한다.

벡터 h를 중간 벡터(halfway vector)라고 부른다. 거시 법선 n과 중간 벡터 h 사이의 각도를 ${\theta}_h$로 정의한다.

전체 미세면 중 n과 h의 각도가 $θ_h$인 미세면들의 비율을 나타내는 분포 함수 $\rho({\theta}_h )\in[0,1]$을 정의해야 한다. 직관적으로 ${\theta}_h$가 0일 때 분포 함수의 값은 최대가 되고, 커질수록 줄어드는 형태이어야 할 것이다. 이 조건을 만족하는 함수들 중 쉽게 제어할 수 있는 함수로 유명한 것이 다음 함수이다.

$\rho({\theta}_h)=cos^m({\theta}_h)=(n \cdot h)^m$

n과 h가 단위 벡터이기 때문에 다음과 같이 쓸 수 있다. 여기서 m은 표면 거칠기를 제어하는 계수로, m이 증가하면 ${\theta}_h$가 조금만 커지더라도 함수값이 빠르게 감소하기 때문에 표면이 매끄러워진다. 반대로 m이 감소하면 함수값이 천천히 감소하여 거친 표면이 된다.

전체적인 빛 에너지를 보존하기 위해서 정규화 계수를 추가하면 최종적인 식은 다음과 같이 된다.

$S({\theta}_h )=\frac{m+8}{8} cos^m({\theta}_h )=\frac{m+8}{8} (n \cdot h)^m$

m이 작으면 거친 표면이므로 빛 에너지가 넓게 퍼지므로 반영 돌출부가 넓어진다. 에너지가 분산되므로 반영 하이라이트가 어두워진다. 반대로 m이 크면 반영 돌출부는 좁아지며 빛 에너지가 집중되어 반영 하이라이트가 밝아진다.

8.7절의 주제인 반영 조명을 종합한 식을 구성하면 다음과 같다.

$c_s=max⁡(L \cdot n,0) \cdot B_L \bigotimes R_F ({\alpha}_h ) \frac{m+8}{8} (n \cdot h)^m$

$B_L$은 입사광, ${\alpha}_h$는 L과 h 사이의 각도이다.

만약 L과 n을 내적한 결과가 음수라면 조명이 뒷면을 비추는 것이므로 아무런 효과가 없다.

## 8.8 조명 모형 정리

표면이 반사하는 빛은 주변광, 분산광, 반영광의 합이다. 주변광은 간접광을 받아 반사하는 빛의 양으로, 물리적인 계산 없이 구했다. 분산광은 매질 내부로 들어가 여러 번 반사한 후 밖으로 흩어지는 빛이며 근사적으로 들어온 빛이 모든 방향으로 고르게 흩어진다고 가정하였다. 반영광은 프레넬 효과와 거칠기에 의해 반사된 빛으로, 시점에 영향을 받는다.
최종적인 조명 방정식은 교재의 398페이지에 나와있다.

## 8.9 재질의 구현

이 책에서 사용할 재질(material) 구조체의 멤버들을 조절하여 원하는 형태의 재질을 만들어낼 수 있다. 교재에서의 조언은 최대한 물리적으로 사실적인 재질 값들을 사용하되 미학적 관점에서 더 나은 결과를 낼 수 있다면 값들을 조절해도 좋다는 것이다.
재질 구조체에서 표면 거칠기(Roughness)를 [0, 1] 구간으로 정규화된 부동소수점 값으로 지정한다. 거칠기가 0이면 매끄러운 표면, 1이면 최대로 거친 표면이다. 표면의 광택도(Shininess)는 1 – 거칠기로 구한다. 셰이더 코드에서는 광택도에 256을 곱해서 지수를 구한다.
이제 실제로 재질을 얼마나 세밀하게 적용할 것인지에 대한 문제가 생긴다. 하나의 표면 위에서 재질 값들이 달라질 수도 있기 때문이다. 예를 들어 자동차를 표현한 모형에서 헤드라이트, 창, 차체, 타이어 등이 각각 재질 값이 다르므로 영역 별로 재질을 다르게 적용해야 한다.
이러한 다양성을 구현하는 한 가지 방법은 정점별로 재질 값을 설정하는 것이다. 정점별로 재질 값을 지정하게 되면 래스터화 단계에서 삼각형을 따라서 보간되므로 각 점에서 재질 값을 구할 수 있다. 그러나 이 방법을 이용해서 재질을 묘사하려면 정점이 그만큼 세밀해야 하는데, 제한된 자원 내에서는 쉽지 않다. 또한 정점 구조체에 자료를 추가해야 하며, 정점별로 색상을 지정할 수 있는 도구가 필요하다.
널리 쓰이는 방법은 텍스처 매핑인데, 이에 대해서는 다음 장에서 설명한다.
이번 장에서는 그리기 호출마다 재질을 다르게 적용하는 방법을 사용한다. 각 재질들을 정의하여 하나의 테이블에 담아둔다.
이 재질들을 셰이더에 전달해야 하므로 재질 특성 상수들을 담은 상수 버퍼를 각 FrameResource에 추가한다.
MaterialConstants 구조체는 Material 자료에서 셰이더가 필요한 자료들만 옮겨담는다.
Update에서는 변경된(NumFramesDirty>0) 재질 자료가 있으면 그것을 상수 버퍼에 새롭게 갱신하여 최신 상태를 유지한다.
이제 RenderItem 구조체에는 재질 인스턴스를 가리키는 포인터가 있다. 각 Material에는 해당 Material의 특성 상수들이 들어있는 상수 버퍼 상의 인덱스가 저장되어 있으므로 재질 상수 버퍼의 시작 지점으로부터 (재질 상수 버퍼의 요소 1개가 차지하는 바이트 수)\*(인덱스) 만큼 증가한 지점을 루트 서술자로 전달하면 된다.
계산을 위해서는 표면의 점마다 법선 벡터가 필요하므로, 각 정점에서 법선을 지정하여 보간을 통해 법선 벡터를 구하도록 한다.

## 8.10 평행광

지향광(directional light)이라고도 하는 평행광(parallel light)은 모든 광선이 평행하다. 아주 멀리에 있는 광원(예를 들면 태양)을 평행광으로 근사할 수 있다. 또한 광원과 물체 사이의 거리로 인해 발생하는 효과를 무시할 수 있다. 따라서 빛의 세기만 지정하면 된다.
평행광원은 광선들이 나아가는 방향을 담은 벡터 하나로 정의된다. 빛 벡터는 광선 방향의 반대 방향이다.

## 8.11 점광

점광(point light)은 모든 방향으로 빛을 발산한다. 평행광과의 차이점은 평행광은 모든 점에 대하여 동일한 빛 벡터를 사용할 수 있지만 점광은 점의 위치에 따라서 빛 벡터가 달라지므로 다시 계산해야 하는 것이다.

### 8.11.1 빛의 감쇠

물리적으로 빛의 세기는 거리의 제곱에 반비례한다. 물리적인 법칙을 따르는 함수는 물리에 근거한 빛 속성 값들을 설정하고 HDR 조명과 톤매핑을 사용할 때에는 좋은 결과를 낸다. 하지만 이 책에서는 더 낮은 비용으로 계산하는 선형 감쇠 함수를 사용한다.
att(d)=saturate((falloffEnd-d)/(falloffEnd-falloffStart))
falloffStart는 감쇠가 시작되는 지점, falloffEnd는 밝기가 0이 되는 지점을 말한다. saturate는 값의 범위를 0에서 1로 고정시키는 함수이다. 이 함수의 함수값은는 d가 falloffStart보다 작을 경우 1, falloffStart부터 falloffEnd까지는 1에서 0까지 선형으로 감소, falloffEnd부터는 0이다. falloffEnd 보다 멀어질 경우 빛을 전혀 받지 못하는데, 이에 해당하는 점들은 조명 계산을 생략하는 식으로 최적화에 활용할 수 있다.
점광의 세기를 계산할 때에는 B_L에 att(d)를 곱하면 된다.

## 8.12 점적광(spotlight)

손전등과 같이 특정한 방향으로 원뿔 형태로 나아가는 빛이다. 위치 Q에서 d방향으로 원뿔 형태로 뻗어나가는 빛을 의미한다. P를 조명을 받는 점의 위치라고 한다면 빛 벡터 L은 normalize(Q-P)로 정의할 수 있다. 점광과는 달리 점적광에서는 원뿔의 중심에서 빛의 세기가 최대이고 중심에서 멀어질수록 빛의 세기가 0으로 감소해야 한다. 빛의 감쇠 계수를 다음과 같이 정의한다.

$k_spot (\phi)=max⁡(cos \phi,0)^s= max⁡(-L \cdot d,0)^s$

이 함수는 빛의 세기가 매끄럽게 감소하는 동시에 ${\phi}_{max}$를 간접적으로 제어할 수 있다. s를 키우면 $\phi$가 증가할 때 빠르게 빛의 세기가 감소한다.

최종적으로 점적광의 세기를 계산하려면 $B_L$에 att(d)와 $k_{spot}$를 곱해서 계산하면 된다. 각 연산에는 추가적인 비용이 필요하므로, 평행광, 점광, 점적광 순으로 연산이 더 많이 필요하다.

## 8.13 조명 구현

조명의 속성들을 하나의 구조체에 담는다. 평행광, 점광, 점적광에 필요한 모든 속성을 담고 있기 때문에 3가지의 빛을 모두 하나의 구조체로 구현할 수 있다. 단, 광선의 종류에 따라서 사용하지 않는 속성들이 있을 수 있다.
상수 버퍼의 요소들은 반드시 4차원 벡터의 형태로 저장(16바이트 단위로 정렬)되며, HLSL에서는 하나의 요소가 두 개의 상수 버퍼에 걸쳐서 저장되는 것을 허용하지 않는다. 예를 들면, float3 a 바로 다음에 float3 b가 위치할 경우 두 개의 4차원 벡터를 사용해야만 한다. 즉, b는 a의 16바이트 뒤에 위치하는 것이다. 하지만 C++에서 구조체를 작성할 때에는 HLSL과는 다른 방식으로 정렬되므로 C++과 HLSL의 구조체를 완전히 동일하게 작성할 경우 memcpy를 통해 메모리를 복사했을 때 올바르게 복사되지 않는다. 따라서 이를 해결하기 위해서는 float3 멤버 다음에 float 멤버 하나를 배치하여 16바이트를 맞추는 것이다. 실제로 Shapes 예제의 PassConstants에서 float3 형식인 EyePosW 다음에 float형의 채움 필드(cbPerObjectPad1)를 배치하여 16바이트를 맞추었다. 자세한 사항에 대해서는 부록의 B.4.3을 참고한다.
정적 정점 버퍼나 동적 정점 버퍼의 경우에는 상수 버퍼에 저장하지 않으므로 위의 규칙을 따를 필요는 없다.
얻을 수 있는 용량 상의 이득이 없다면 그냥 채움 필드를 사용하여 직관적이도록 배치하는 것 같다.
Light 구조체도 위의 규칙을 따라서 정의한다.

### 8.13.2 공통 보조 함수들

LightingUtils.hlsl에는 빛을 계산할 때 자주 쓰이는 보조 함수들이 정의되어 있다. 목록은 다음과 같다.

1. CalcAttenuation: 선형 감쇠 계수를 계산한다.
2. SchlickFresnel: 프레넬 방정식의 슐릭 근사를 구한다.
3. BlinnPhong: 분산광과 반영광의 합을 반환한다.
   이 소스를 볼 때 알아두어야 할 점은 두 벡터를 곱하기 연산자 \*로 연산하면 성분별 곱셈이 수행된다는 것이다.

### 8.13.3 지향광의 구현

지향광의 결과를 결정하는 요소는 시점 벡터(점에서 눈으로 향하는 벡터), 법선 벡터, 재질, 그리고 빛의 속성들 중에서는 세기, 방향이 필요하다.
람베르트 코사인 법칙을 이용하여 실제로 입사하는 빛의 세기를 구한 다음 BlinnPhong 함수를 호출한다.
ComputeDirectionalLight 함수는 하나의 평행광에서 나온 빛이 표면의 점에서 normalize(E-p) 방향으로 반사되는 빛의 양을 반환한다.

### 8.13.4 점광의 구현

점광의 결과를 결정하는 요소는 시점 벡터, 점에 대한 위치 벡터(거리에 따른 감쇠를 구하기 위한), 법선 벡터, 재질, 빛의 속성들 중에서는 세기, falloffStart, falloffEnd, 광원의 위치가 필요하다.
일단 광원에서 점까지 떨어진 거리를 구한 다음, 거리가 falloffEnd보다 멀다면 바로 0을 반환한다.
람베르트 코사인 법칙과 선형 감쇠 함수를 적용하여 빛의 세기를 구하고, 이를 BlinnPhong에 전달해 최종적인 결과를 구한다.
ComputePointLight 함수는 하나의 점광에서 나온 빛이 표면의 점에서 normalize(E-p) 방향으로 반사되는 빛의 양을 반환한다.

### 8.13.5 점적광의 구현

점적광의 결과를 결정하는 요소는 시점 벡터, 점의 위치, 법선 벡터, 재질, 빛의 속성 전체(세기, falloffStart, falloffEnd, 광원의 위치, 점적광 세기 감쇠 지수)가 필요하다.
람베르트 코사인 법칙, 선형 감쇠 함수, 점적광 감쇠 계수를 모두 적용하여 세기를 구한 다음 BlinnPhong 함수를 호출한다.

### 8.13.6 여러 빛의 누적

하나의 장면에서 여러 개의 광원을 지원하려면 각 광원에 의한 빛을 누적하면 된다. 이 책의 프레임워크는 최대 16개의 광원을 지원한다. 평행광원, 점광원, 점적광원 순서대로 광원 배열에 배치하며 각 광원의 개수를 임의로 조절할 수 있다. 각 광원의 개수를 매크로(HLSL의 매크로는 C++과 거의 비슷함)를 이용해서 셰이더에서 처리할 조명의 개수를 조절할 수 있다.

## 8.14 파도 조명 예제

파도 조명에서 언덕의 법선 벡터는 편미분을 이용하여 구한다(필기자료 참고).
구현할 때에 주의할 점은 이전에는 mEyePos를 굳이 갱신하지 않아도 되었지만, 이번에는 mEyePos를 메인 패스 상수 버퍼에 조명 계산을 위하여 전달할 때 사용하기 때문에 갱신을 해주어야 한다.
