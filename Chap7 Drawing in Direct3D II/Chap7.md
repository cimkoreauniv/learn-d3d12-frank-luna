# 7. Direct3D의 그리기 연산 2부

7장에서는 프레임 자원을 도입하여 CPU와 GPU를 동기화할 필요가 없도록 한다. 다음에는 렌더 항목이라는 개념을 소개하고 상수 자료를 갱신 주기에 근거해서 분할하는 방법을 설명한다. 또한 6장에서 이야기하지 않았던 루트 매개변수들인 루트 서술자와 루트 상수를 설명한다. 마지막으로는 상자보다 복잡한 물체들을 그려본다.

## 목표

1. 프레임마다 명령 대기열을 비우지 않아도 되도록 렌더링 공정을 수정함으로써 성능을 향상하는 방법을 배운다.
2. 다른 두 종류의 루트 서명 매개변수인 루트 서술자와 루트 상수를 배운다.
3. 격자, 원기둥, 구 같은 일반적인 기하 도형들을 절차적으로 생성하고 그리는 방법을 파악한다.
4. CPU에서 정점들을 애니메이션하고 새 정점 위치들을 동적 정점 버퍼를 이용해서 GPU에 올리는 방법을 알아본다.

## 7.1 프레임 자원

GPU가 처리를 마치기 전(즉, 해당 자료들을 참조하기 전)에 재설정하면 안 되는 것들은 명령 할당자(command allocator), 상수 버퍼 등이 있다. 그렇기 때문에 기존에는 FlushCommandQueue를 이용해서 기존에 내렸던 명령이 모두 실행될 때까지 대기했다. 여기에는 두 가지 문제점이 있다. 첫 번째로 GPU가 할 일을 끝마치고 난 후에 CPU가 command list를 작성하여 큐에 제출할 때까지 기다려야 하므로 할 일이 없다. 반대로 CPU는 command list를 제출한 직후에는 GPU가 할 일을 마칠 때까지 기다려야 하므로 할 일이 없다. 따라서 CPU와 GPU가 번갈아 가면서 놀게 된다. 이 문제를 해결하기 위해 본 교재에서는 CPU가 수정해야 할 자원들을 순환 배열의 형태로 관리한다. 이러한 자원들을 프레임 자원(frame resource)라고 칭한다. GPU가 이전 프레임 자원들을 처리하는 동안 CPU는 다음 프레임에 해당하는 자원들을 처리한다. 이 책에서는 프레임 자원을 3개 사용하며, 따라서 CPU는 GPU에 비해 최대 2프레임 앞설 수 있다. 프레임 자원들을 생성하고 지속적으로 갱신하는 것을 통해 CPU와 GPU를 지속적으로 일하게 할 수 있다.

## 7.2 렌더 항목

한 장면에서 그릴 물체가 여러 개일 때 설정들을 한 번에 관리하기 위해서 만드는 자료 집합을 렌더 항목(render item)이라고 한다. 각 응용 프로그램별로 구현하는 효과나 렌더링 기법이 다를 수 있으므로 각 프로젝트별로 렌더 항목을 만든다. 응용 프로그램에서는 물체들을 그리는 방식, 즉 PSO에 따라서 렌더 항목들을 분류한다. 예를 들면 불투명한 물체들과 투명한 물체들을 나누어 그리는 식이다.

## 7.3 패스(Pass)별 상수 버퍼

여기서부터는 오브젝트별 상수 버퍼와 패스별 상수 버퍼로 구분한다. 패스별 상수 버퍼에는 하나의 렌더링 패스(간단한 정의로는 렌더링 파이프라인의 한 사이클, 더 자세한 정의들도 있는 듯하다)동안 변하지 않는 상수 자료들을 의미한다. 즉, 여기서는 프레임마다 갱신해주는 자료들이다. 반면에 오브젝트별 상수 버퍼는 물체가 움직이지 않는 이상은 초기화시에 위치를 지정한 다음에는 갱신할 필요가 없으므로 자원을 절약할 수 있다. 각 물체의 world matrix는 오브젝트별 상수 버퍼에 저장하고 view matrix, projection matrix 등은 패스별 상수 버퍼에 저장한다.

## 7.4 도형 기하구조

교재에서 GeometryGenerator 클래스를 제공한다. 이를 이용해서 상자, 구, 측지구(GeoSphere), 원기둥, 평면 등의 구조들의 정점 버퍼와 상수 버퍼를 생성할 수 있다.

## 7.5 도형 예제(Shapes)

### 7.5.1 정점 버퍼와 색인 버퍼

모든 기하구조들을 하나의 정점 버퍼와 색인 버퍼로 만든다.

### 7.5.2 렌더 항목

그리드와 박스의 경우 1개만 있으므로 한 번만 생성하면 되지만 구와 기둥의 경우 여러 개를 생성해야 하므로 World matrix는 다르되 기하 구조는 동일한 것을 활용하여 여러 개의 렌더 아이템을 만든다.

### 7.5.3 프레임 자원들과 상수 버퍼 뷰들

프레임 자원들 각각에 대하여 오브젝트별 상수 버퍼들과 패스별 상수 버퍼를 만들어야 하므로 총 3\*(오브젝트 수+1)개만큼의 상수 버퍼 뷰가 필요하다. 순서는 (0번 프레임 자원의 오브젝트)(1번-오브젝트)(2번-오브젝트)(0번-패스)(1번-패스)(2번-패스)순으로 배치한다.

상수 버퍼 뷰를 생성할 때에 해당 자료의 위치를 서술하는 서술자의 CPU 핸들을 넘겨주어야 한다. 6장에서는 하나의 상수 버퍼만 사용했으므로 그냥 시작 위치를 그대로 사용하면 되었으나 이번에는 상수 버퍼가 여러 개이므로 서술자의 위치를 시작 위치를 기반으로 알아내야 한다. Cbv 힙의 증가치는 mCbvSrvUavDescriptorSize에 들어있으므로 이를 바탕으로 증가시키면 된다. 해당 기능은 편의용 클래스인 CD3DX12_CPU_DESCRIPTOR_HANDLE에서 Offset 메서드로 제공한다.

CBV 힙을 만드는 과정: UploadBuffer 클래스를 이용하여 상수 버퍼를 생성. CBV들을 담을 CBV 힙 생성. 마지막으로 CBV 힙에 CBV들을 채워넣는다.

### 7.5.4 장면 그리기

각 렌더 아이템에 저장된 데이터들을 기반으로 렌더 아이템들을 그린다. 이 때 서술자 테이블을 설정해주어야 하는데, 오브젝트별 상수 버퍼는 0번, 패스별 상수 버퍼는 1번에 전달하므로 SetGraphicsRootDescriptorTable의 첫 번째 인자인 RootParameterIndex를 이용하여 세팅한다.

## 7.5 번외: 도형 구현 시 주의할 점

Initialize를 작성할 때 먼저 만들어놓은 함수들을 호출하는 방식으로 구현한다. 이 때 의존 관계를 잘 파악하여 함수의 순서를 올바르게 정해야 한다. 예를 들면, BuildConstantBufferViews의 경우 렌더 아이템과 프레임 자원이 만들어져 있어야 하므로, 사전에 BuildRenderItems과 BuildFrameResources가 호출되어야 한다.

## 7.6 루트 서명 추가 설명

### 7.6.1 루트 매개변수

앞서 루트 매개변수로 3가지 종류가 가능함을 알아보았는데, 각각 서술자 테이블, 루트 서술자, 루트 상수이다.

서술자 테이블은 힙 안에 있는 서술자들의 구간을 지정한다.

루트 서술자(인라인 서술자)는 그 자체가 하나의 서술자이며, CBV나 기타 자원 버퍼들에 대한 SRV/UAV만 지정이 가능하다. 예를 들면 텍스처에 대한 SRV는 루트 서술자로 지정이 안된다.

루트 상수는 직접 묶을 32비트 상수 값들의 목록이다.

하나의 루트 서명에는 성능상의 이유로 최대 64개의 DWORD(4바이트)만 넣을 수 있다. 각 루트 매개변수의 비용은 서술자 테이블(DWORD 1개), 루트 서술자(DWORD 2개), 루트 상수(차지하는 만큼)이다.

간단한 형태의 루트 서명이라면 루트 상수들로 만들 수 있겠지만, float 4x4 행렬만 하더라도 16개의 DWORD이므로 1/4를 차치하게 된다. 따라서 상수 버퍼 자료가 커지는 경우 위의 세 가지를 적절히 조합하여 사용할 가능성이 크다.

앞서 사용한 CD3DX12_ROOT_PARAMETER의 경우 D3D12_ROOT_PARAMETER를 상속한 래퍼 클래스이다. D3D12_ROOT_PARAMETER의 속성들에 대해서 알아보자.

D3D12_ROOT_PARAMETER_TYPE ParameterType: 루트 매개변수의 종류(서술자 테이블, CBV 루트 서술자, SRV 루트 서술자, UAV 루트 서술자) 중 하나를 지정한다.

DescriptorTable/Constants/Descriptor 공용체: 루트 매개변수를 서술하는 구조체이다. 공용체이므로 루트 매개변수의 종류에 해당하는 것으로 채우면 된다.

ShaderVisibility: 해당 루트 매개변수들을 참조할 수 있는 셰이더 프로그램들을 지정한다. 본 교재에서는 주로 ALL을 사용하여 모든 셰이더 프로그램에서 볼 수 있도록 하지만 만약 특정한 셰이더만 참조하는 것이 확실하다면 다른 숫자를 지정하면 최적화를 할 여지가 생길 수 있다.

### 7.6.2 서술자 테이블

서술자 테이블 루트 매개변수를 정의하기 위해서는 루트 매개변수의 속성 공용체의 멤버이면서 D3D12_ROOT_DESCRIPTOR_TABLE형인 DescriptorTable을 채워넣어 전달해야 한다. 해당 자료형은 배열의 시작주소를 담는 D3D12_DESCRIPTOR_TABLE형 포인터와 배열 원소의 개수로 이루어져 있다. D3D12_DESCRIPTOR_RANGE 구조체는 다음 멤버들로 구성된다.

1. RangeType: 열거형의 한 멤버로, 서술자의 종류를 나타낸다.
2. NumDescriptors: 서술자의 개수
3. BaseShaderRegister: 시작 레지스터 번호이다. 예를 들어 NumDescriptors가 2이고 BaseShaderRegister가 1이라면 1번, 2번에 연결된다.
4. RegisterSpace: 레지스터를 구분하는 또 하나의 인자이다. 기본적으로 레지스터는 space0를 사용하지만 자원들의 배열의 경우에는 여러 개의 공간을 사용하는 것이 유용하며 크기를 미리 알 수 없을 경우 다중 공간 사용이 필수이다.
5. OffsetInDescriptorsFromTableStart: 서술자 테이블의 시작으로부터 이 Descriptor range가 시작하는 위치까지 떨어진 거리. 예를 들어, CBV 2개, SRV 3개, UAV 1개로 이루어진 서술자 테이블을 정의한다면 D3D12_DESCRIPTOR_RANGE가 3개 필요하며, 첫 번째 Range의 offset은 0, 두 번째는 2, 세 번째는 5인 것이다. CD3DX12_DESCRIPTOR_RANGE 래퍼 클래스에서 지정해주는 기본값인 D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND를 지정한다면 이전 구간을 기준으로 하여 자동으로 offset값을 계산해준다. 그러므로 서술자 테이블에 서술자들을 지정할 때 앞에서부터 채워야 한다.

### 7.6.3 루트 서술자

루트 매개변수 하나를 서술자로 만들 수 있으며, 이를 위해 D3D12_ROOT_PARAMETER형의 Descriptor 멤버를 채워넣는다. 여기에는 셰이더 레지스터의 번호(ShaderRegister)와 레지스터 공간(RegisterSpace)의 두 개의 정수만 채우면 된다.

레지스터의 종류는 이후에 command list에서 SetGraphicsRoot(서술자 종류)View를 통해 직접 자원의 가상 GPU 주소를 전달한다.

### 7.6.4 루트 상수

D3D12_ROOT_CONSTANTS형인 Constants의 요소들을 채워넣어야 한다. 여기의 멤버는 이와 같다.

ShaderRegister: 이전과 동일

RegisterSpace: 이전과 동일

Num32BitValues: 이 루트 매개변수가 기대하는 32비트 상수들의 개수

셰이더의 관점에서는 루트 상수가 하나의 상수 버퍼 자료와 동일하게 취급된다.

상수를 실제로 전달하기 위해서는 command list의 SetGraphicsRoot32BitConstants를 통해 전달하며, 32비트 데이터들이 들어있는 CPU의 메모리 주소를 입력해야 한다.

### 7.6.5 좀 더 복잡한 루트 서명 예제

다양한 데이터들을 전송하기 위해 루트 매개변수를 작성하는 예시가 나와 있다.
성능을 위해서는 사용 빈도가 높은 매개변수일수록 루트 매개변수들의 앞쪽(낮은 인덱스)에 배치하는 것이 좋다.

### 7.6.6 루트 인수의 버전 적용(?)

함수에서의 parameter(매개변수)와 argument(인수)의 관계와 동일하게 셰이더에 전달할 형식을 정의하는 것이 root parameter, 실제로 전달되는 값을 root argument라고 한다. 루트 서명에 있는 데이터들을 셰이더가 모두 사용할 필요는 없으므로 더 많은 데이터를 제공할 수 있다.

성능을 위해서는 루트 매개변수를 변하는 빈도가 높은 것에서 낮은 순으로 배치하는 것이 좋다. 또한 루트 서명의 전환을 최대한 피하는 것이 좋으므로 여러 개의 PSO가 동일한 루트 서명을 공유하도록 하면 좋다. 구체적으로 여러 셰이더 프로그램들과 호환되는 ‘슈퍼’ 루트 서명을 두는 것이 도움이 된다. 단, 슈퍼 루트 서명이 너무 크다면 오히려 프로그램이 느려질 수 있으므로(즉, 루트 서명을 전환하는 것이 차라리 나은 상황) 주의해야 한다.

## 7.7 지형과 파도 예제

### 7.7.1 격자 정점 생성

GeometryGenerator 클래스에 있는 CreateGrid의 원리에 대한 설명이 나와있다. 정점들을 생성하는 공식과 정점들을 잇는 색인들을 생성하는 방법에 대하여 설명한다.

### 7.7.3 높이 함수 적용

CreateGrid를 통해 생성된 평면 상의 정점들에 높이를 부여한다. 또한 높이에 따라서 정점의 색이 달라지도록 적용한다. 높이는 cos과 sin을 활용하여 언덕이 곡선 형태로 나오도록 정의했다.

### 7.7.4 루트 CBV

앞의 Shapes 예제에서 루트 매개변수에 서술자 테이블을 사용했던 것과는 달리 이번에는 루트 서술자를 사용한다. 구체적으로 두 개의 상수 버퍼를 루트 CBV를 통해서 전달하므로 CBV힙이 필요 없는 것이다. 데이터를 전달하기 위해서는 command list의 SetGraphicsRootConstantBufferView를 호출한다.

### 7.7.5 동적 정점 버퍼

지금까지의 예제들은 정점을 기본 버퍼에 저장하여 수정할 수 없었다. 하지만 파도의 경우에는 실시간으로 높이가 변하기 때문에 정점의 위치를 변경해야 하므로 동적 정점 버퍼가 필요하다. 동적 정점 버퍼가 필요한 또 다른 예시로는 물리 연산을 하는 경우인데, CPU에서 물리 연산을 수행한 다음 입자들의 위치를 갱신한다.

정점들의 위치는 프레임마다 갱신되므로 프레임 자원으로 놓아야 한다. 매 프레임마다 파도 시뮬레이션을 실행하고 동적 정점 버퍼를 갱신한다.

동적 버퍼를 사용하면 CPU의 자원을 GPU 메모리로 전송해야 하므로 추가적인 비용이 발생한다. 따라서 반드시 필요할 때만 사용해야 한다. D3D의 최신 버전들에는 동적 버퍼의 필요성을 줄여주는 새로운 기능들이 추가되었다. 몇 가지 예시로는

1. 정점 셰이더에서 간단한 애니메이션을 구현할 수 있다.
2. 텍스처로의 렌더링 기능이나 계산 셰이더 또는 정점 텍스처 조회 기능을 이용하면 파도 시뮬레이션을 GPU에서 자체적으로 수행하는 것이 가능해진다.
3. 기하 셰이더를 이용하면 이전에는 CPU에서 수행해야 했던 기본도형의 생성 및 파괴 작업을 GPU에서 수행할 수 있다.
4. 테셀레이션 단계들을 이용하면 GPU에서 세밀한 기하구조를 장면에 추가할 수 있다.
