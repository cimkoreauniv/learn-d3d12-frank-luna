# Chap9 텍스처 적용

텍스처 매핑은 메시의 삼각형에 이미지 자료를 입히는 기법으로, 장면의 세부도와 사실감을 높일 수 있다.

## 목표

1. 텍스처 이미지 중 주어진 삼각형에 입힐 부분을 지정하는 방법을 배운다.
2. 텍스처를 생성하고 텍스처 매핑을 활성화하는 방법을 파악한다.
3. 텍스처를 필터링해서 더 매끄러운 모습을 만들어 내는 방법을 배운다.
4. 좌표 지정 모드를 이용해서 하나의 텍스처를 타일처럼 여러 번 적용하는 방법을 알아본다.
5. 여러 장의 텍스처를 조합해서 새로운 텍스처를 만들고 특수효과를 구현하는 방법을 파악한다.
6. 텍스처 애니메이션으로 기본적인 효과 몇 가지를 만들어 내는 방법을 배운다.

## 9.1 텍스처와 자원의 개괄

텍스처는 이미 4장부터 사용해 왔다. 사실 깊이 버퍼와 후면 버퍼는 ID3D12Resource 인터페이스로 대표되는 2차원 텍스처 객체들이다.

2차원 텍스처는 자료 원소들의 2차원 배열이다. 2차원 텍스처의 용도 중 하나는 각 원소에 색상을 담아 이미지를 저장하는 것이다. 그러나 이것이 유일한 용도는 아니다. 예를 들어 노멀 매핑에서는 텍스처의 각 원소가 3차원 벡터를 담는다. 일반적으로 텍스처라고 하면 이미지 자료의 저장을 떠올리지만, 실제로는 훨씬 범용적이다. 1차원, 2차원, 3차원 텍스처 모두 ID3D12Resource를 통해 대표된다.

텍스처와 버퍼 자원에는 차이가 있다. 버퍼는 그냥 자료 배열만 저장하지만 텍스처에는 밉맵 수준들이 존재할 수 있고, GPU가 필터링, 다중표본화 등의 특별한 연산을 적용할 수 있다. 이러한 특별한 연산들 때문에 텍스처에는 특정 종류의 자료 형식만 담을 수 있다. 반면 버퍼 자원에는 임의의 자료를 담을 수 있다. 텍스처에 담을 구체적인 자료 형식은 DXGI_FORMAT 열거형으로 지정한다. 예를 들어, DXGI_FORMAT_R32G32B32_FLOAT 원소 형식은 float형의 3차원 벡터를 담을 수 있다. 무형식 텍스처의 경우 그냥 메모리만 확보해두고 각 성분의 구체적인 자료형은 지정하지 않되, 나중에 텍스처를 파이프라인에 묶을 때 구체적인 해석 방식을 지정한다. 다만 형식이 완전히 지정된 자원의 경우 해당 형식으로만 사용하는 것이 보장되기 때문에 최적화의 여지가 생기며, 따라서 무형식은 꼭 필요한 경우에만 활용하는 것이 좋다.

렌더링 파이프라인에 텍스처를 묶을 수 있는 단계는 여러 가지가 있다. 흔한 예시는 텍스처 자원을 렌더 타겟으로 묶는 것과 셰이더 자원으로 묶는 것이다. 하나의 텍스처를 렌더 대상이자 셰이더 자원으로 사용하는 것도 가능하나, 동시에 사용할 수는 없다. 장면을 텍스처에 렌더링 한 다음 그 텍스처를 셰이더 자원으로 사용하는 기법을 텍스처 대상 렌더링(render-to-texture)라고 한다. 이 기법을 사용하려면 하나의 텍스처 자원에 대한 서술자를 2개 만들어야 하며, 하나는 렌더 대상(RTV) 힙에 두고 다른 하나는 CRV_SRV_UAV 힙에 두어야 한다. 이후에는 렌더 대상이나 루트 서명에 묶으면 된다.

자원 서술자들은 본질적으로 두 가지의 역할을 한다. 첫 번째는 D3D에게 자원의 용도(자원이 파이프라인의 어느 단계에 묶이는지)와 무형식 자원의 구체적인 형식을 결정하는 것이다.

이번 장에서는 픽셀 셰이더에서 텍스처의 표본을 추출해 픽셀의 색상으로 사용할 수 있도록 텍스처를 셰이더 자원으로 묶어서 사용하는 방식만 이야기한다.

## 9.2 텍스처 좌표

텍스처를 구성하는 요소들을 텍셀(texel)이라고 한다. 특정한 텍셀 하나는 0≤u,v≤1인 (u,v)의 텍스처 좌표로 식별한다. v는 일반적인 좌표계와는 달리 위에서 아래로 향한다. 텍스처는 정규화된 좌표를 사용하므로 (0.5, 0.5)는 텍스처의 실제 크기와는 관계없이 항상 중앙의 텍셀에 해당한다.

물체에 텍스처를 입히려면 각 3차원 삼각형이 텍스처 상의 어느 부분에 대응되는가를 지정해야 한다. 삼각형을 이루는 3개의 정점과 텍스처 좌표를 대응시키면 보간을 통해 삼각형 위의 모든 점들에 대응되는 텍스처 좌표가 결정된다.

정점 구조체에 텍스처의 한 점을 지정하는 텍스처 좌표 성분(2차원 벡터)를 추가한다. 그러면 세 개의 정점으로 이루어진 삼각형을 하나 만들면 그에 따라서 텍스처 상에도 삼각형을 정의할 수 있게 된다.

좌표를 적절히 지정하면 텍스처의 일부분만 면에 입히는 것이 가능하다. 실제 응용에서는 여러 종류의 텍스처들을 모아 하나의 큰 텍스처 맵(texture atlas)를 만들고 각 부분을 서로 다른 물체들에 적용하기도 한다.

## 9.3 텍스처 자료 원본

이미지 형식에는 PNG, JPG 등 여러 가지가 있지만, 실시간 그래픽에서 즐겨 사용하는 형식은 GPU에 특화된 이미지 형식인 DDS(DirectDraw Surface format)이다.

### 9.3.1 DDS의 개요

DDS는 GPU를 위해 만들어진 이미지 형식이다. DDS는 밉맵 등 3D 그래픽에 쓰이는 여러 가지 기능들을 지원한다.

DDS 형식은 다양한 픽셀 형식을 지원한다. 픽셀 형식은 DXGI_FORMAT 열거형이며, 압축되지 않은 이미지 자료에서 주로 쓰이는 형식은 LDR에서는 B8G8R8A8_UNORM이나 B8G8R8X8_UNORM이고, HDR에서는 R16G16B16A16_FLOAT이 쓰인다.

텍스처의 양이 많아진다면 VRAM이 많이 필요하게 된다. 그래서 D3D에서는 여러 가지 압축 형식을 지원한다.

압축의 장점은 GPU가 필요할 때 즉석에서 압축을 풀 수 있다는 것과 보조 기억 장치 공간이 절약된다는 점이다.

### 9.3.2 DDS 파일 만들기

포토샵에서 플러그인을 활용하거나 마이크로소프트에서 지원하는 texconv라는 도구를 사용하면 된다.

## 9.4 텍스처 생성 및 활성화

### 9.4.1 DDS 파일 불러오기

이 책을 작성하는 시점에서 마이크로소프트 공식 깃허브에 올라와 있는 DDSTextureLoader는 DirectX 11만 지원하기 때문에 저자가 적당히 소스 코드를 수정하여 DirectX 12를 위한 함수를 추가했다. 함수의 이름은 CreateDDSTextureFromFile12이다.

### 9.4.2 SRV 힙

텍스처 자원을 생성한 다음에는 그 자원에 대한 SRV(Sequential Read View)를 생성해야 한다. 일단 SRV를 담을 CBV_SRV_UAV 힙을 생성한다.

### 9.4.3 SRV 생성

D3D12_SHADER_RESOURCE_VIEW_DESC를 채워 SRV를 생성한다. DESC 구조체는 자원의 용도와 기타 정보를 담는다.

구조체의 첫 3개의 필드는 다음과 같다.

1. DXGI_FORMAT Format: 자원의 형식이다. 자원에 형식이 있다면 그 형식을 그대로 쓰고, 무형식이라면 구체적인 형식을 언급해야만 한다.
2. D3D12_SRV_DIMENSION ViewDimension: 자원의 차원. 2차원 텍스처라면 D3D12_SRV_DIMENSION_TEXTURE2D를 지정한다.
3. UINT Shader4ComponentMapping: 셰이더에서 텍스처의 표본을 추출하면 텍스처 자료를 담은 벡터가 반환된다. 이 필드는 반환되는 벡터 성분들의 순서를 바꾸는 역할을 한다. 예를 들면 적색 성분과 녹색 성분을 교환하는 것이다. 이 책에서는 그러한 상황이 없기 때문에 변경 없이 그대로 돌려주는 D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING을 사용한다.
   이 다음에는 자원의 속성들을 담는 공용체가 있는데, 이 속성은 다양한 형태의 셰이더 자원에 대한 속성들을 담을 수 있다.
   여기서는 2차원 텍스처에 대한 정보인 D3D12_TEX2D_SRV를 채우면 된다. 이 구조체의 필드는 4개이다.
4. MostDetailedMip: 이 뷰에 대해 가장 세부적인 밉맵 수준의 색인을 지정한다. 0이상 MipCount(텍스처 자원을 생성할 때 밉맵의 개수)-1을 지정한다.
5. MipLevels: MostDetailedMip부터 시작하는 이 뷰의 밉맵 개수이다. 위의 MostDetailedMip과 조합하면 전체 밉맵 중 일부분을 지정할 수 있다. 마지막 밉맵까지로 지정하고 싶다면 -1을 저장한다.
6. PlaneSlice: 특정 자원 형식들에서는 이미지가 여러 개의 평면으로 이루어져 있다. 이 책에서는 항상 평면이 1개이므로 0을 지정하면 된다.
7. ResourceMinLODClamp: 접근 가능한 최소 밉맵 수준이다. 모든 밉맵에 접근할 수 있도록 하려면 0.0을 지정하면 된다.

CreateShaderResourceView를 통해 SRV를 생성한다.

### 9.4.4 텍스처를 파이프라인에 묶기

텍스처를 사용하면 더 세밀하고 사실적인 장면을 그려낼 수 있다. 텍스처 매핑은 재질 자료를 재질 상수 버퍼가 아닌 텍스처 맵으로부터 가져온다. 그러면 픽셀별로 재질을 다르게 적용할 수 있다.

이번 장에서는 분산 반사율 텍스처 맵을 응용 프로그램에 추가하여 그 값들을 사용한다. 프레넬 효과에서 R0와 거칠기 값은 이전과 같이 재질 상수 버퍼에서 가져온다. 텍스처를 이용해서 표면 거칠기를 픽셀 수준에서 지정하는 방법은 이후 법선 매핑(노멀 매핑)에서 다룬다.

여전히 재질 상수 버퍼에 분산 반사율(DiffuseAlbedo) 값은 들어있다. 최종적인 분산 반사율 값은 상수 버퍼의 분산 반사율과 텍스처의 분산 반사율의 곱으로 표현된다.

일반적으로 DiffuseAlbedo 값은 (1,1,1,1)로 두므로 텍스처의 값이 그대로 적용될 것이다. 만약 DiffuseAlbedo 값을 바꾸게 된다면 특정한 효과를 텍스처의 변경 없이 적용할 수 있게 된다.

재질을 정의하는 구조체에 서술자 힙의 SRV를 가리키는 색인에 해당하는 필드를 추가한다.

참고: 텍스처 자원은 모든 종류의 셰이더가 접근할 수 있지만, 일단은 픽셀 셰이더에서만 접근하는 것으로 한다.

참고: 텍스처 대지도를 사용하면 한 번의 그리기 호출로 여러 개의 물체를 그릴 수 있으므로 효율적이다. 다만 D3D12에서는 그리기 호출을 하는데에 드는 오버헤드가 줄었다.

## 9.5 필터

### 9.5.1 확대(magnification)

256x256 텍스처 이미지가 표시되는 부분이 1024x1024가 되었다고 해보자. 그러면 적은 수의 텍셀로 많은 수의 픽셀을 채워야 한다. 이 경우 텍스처의 확대가 일어난다. 텍셀의 점과 일치하지 않는 지점들은 보간(interpolation)을 통해 결정한다.

상수 보간(constant interpolation)은 nearest neighbor point sampling이라고도 부르며, 가장 가까운 텍셀의 색으로 보간한다. 예를 들어, x=30에서의 값이 1, x=31에서의 값이 2라면 x=30.3에서의 값은 1.0인 것이다.

선형 보간(linear interpolation)은 두 점 사이를 선형으로 보간한다. 예를 들어, x=30에서의 값이 1, x=31에서의 값이 2라면 x=30.3에서의 값은 1.3인 것이다. 대부분의 경우에 선형 보간을 사용한다.

텍스처는 2차원 자료이므로 이중선형 보간(bilinear interpolation)을 사용한다. 이것은 (u, v) 좌표의 값을 알아내기 위해 u 방향으로 선형 보간을 한 다음 v 방향으로 다시 선형 보간을 수행하는 것이다.

상수 보간에 비해 선형 보간은 색이 매끄럽다. 그러다 보간을 하면 당연히 고해상도 텍스처에 비해서는 품질이 떨어질 것이다.

가상 카메라가 장면을 자유롭게 돌아다닐 수 있다면 확대는 필연적인 문제이다. 그래서 표면에 가까이 가는 것을 막는 식으로 문제를 해결할 수 있다.

### 9.5.2 축소(minification)

축소는 다수의 텍셀이 소수의 픽셀에 사상된다. 축소에서도 확대와 마찬가지로 보간 필터링을 사용할 수 있다. 메모리를 조금 더 사용하여 축소를 효율적으로 근사하는 방법을 밉매핑(mipmapping)이라고 한다. 텍스처를 생성하는 시점에서 주어진 이미지를 하향표본화(downsampling)해서 텍스처의 낮은 해상도 버전들을 만든다. 그런 버전들을 밉맵 수준(mipmap level)이라고 부르며, 하나의 밉맵 사슬(mipmap chain)을 형성한다. 렌더링 도중에 텍스처를 적용할 때 그래픽 하드웨어는 밉맵 설정에 기초해서 두 방식 중 하나를 사용한다.

첫 번째는 상수 보간과 비슷하게 해상도에 가장 잘 맞는 밉맵 수준 하나를 선택하는 것이다. 이 방식을 점 필터링이라고 한다.

두 번째는 선형 보간과 비슷하게 기하구조의 해상도에 가장 가까운 이웃한 두 밉맵 수준을 선택하여 각각 필터링을 적용해서 색상을 뽑고, 두 색상을 보간해서 최종 색상을 결정한다. 이 방식을 선형 필터링이라고 한다.

밉맵 사슬에서 가장 적합한 밉맵 수준을 선택하면 축소가 일어나는 정도가 줄어든다.

### 9.5.3 비등방 필터링

앞에서 사용된 필터링들은 다각형의 법선 벡터와 카메라의 시선 벡터 사이의 각도가 클 때 왜곡현상이 발생한다. 비등방 필터링(anisotropic filtering)은 비용이 가장 비싸지만 왜곡을 최소화할 수 있다.

## 9.6 텍스처 좌표 지정 모드

텍스처 좌표가 [0, 1]을 벗어났을 때 어떻게 처리할 것인지를 알려주는 항목이다. D3D는 총 4가지 모드를 지원한다.

1. 순환 모드에서는 이미지를 그대로 반복한다. 즉 주기함수 형태로 나타난다.
2. 테두리 색상 모드에서는 범위를 벗어난 좌표에 대해서 프로그래머가 지정한 색상을 반환한다.
3. 한정 모드에서는 범위 밖의 좌표에서 해당 좌표와 가장 가까운 [0, 1]상의 점(즉, 경계선을 늘인 형태)의 색상을 반환한다.
4. 반사 모드는 순환 모드와 유사하지만 이미지를 이어붙일 때 뒤집히며 이어진다는 것만 다르다.
   좌표 지정 모드는 항상 지정되며, 기본값은 가장 많이 쓰이는 순환 모드이다.
   순환 모드를 이용하면 타일링(한 이미지를 반복해서 이어붙이는 것)이 가능하다. 타일링을 적용할 때 주의할 점은 이음매가 보이지 않도록(예를 들면 우측 끝과 좌측 끝이 이어지는 것) 텍스처를 디자인해야 하는 것이다. 타일링은 추가적인 자료 없이 텍스처의 해상도를 높이는 효과를 낸다.

## 9.7 표본추출기 객체

앞의 내용을 통해 텍스처를 적용할 때 필요한 것이 텍스처 자료, 텍스처 필터링, 그리고 좌표 지정 모드임을 알 수 있다. 표본을 추출할 때 필터링과 좌표 지정 모드를 무엇으로 할지를 표본추출기 객체(sampler object)를 통해 지정한다. 하나의 응용 프로그램은 텍스처를 여러 방식으로 추출하기 위해 여러 개의 표본추출기 객체를 사용한다.

### 9.7.1 표본추출기 생성

표본추출기는 셰이더에서 쓰이므로 표본추출기 객체에 대한 서술자를 원하는 셰이더에 묶어야 한다.

표본추출기는 셰이더에 서술자 테이블을 통해 전달해야만 한다(이유는 7.6.1 참고).

표본추출기 힙을 생성한 다음, 표본추출기들을 생성하고 그 서술자들을 힙에 추가한다. 이를 위해서 D3D12_SAMPLER_DESC 구조체를 채워 device의 CreateSampler 함수를 통해 표본추출기를 생성한다.

### 9.7.2 정적 표본추출기

대체로 그래픽 응용 프로그램이 사용하는 표본추출기의 수는 그리 많지 않다. 그러므로 D3D에서는 표본추출기 배열을 바로 넘겨서 표본추출기를 위한 서술자 테이블을 만들지 않도록 할 수 있다. 이를 정적 표본추출기라고 한다. 정적 표본추출기는 루트 매개변수가 불필요하므로 루트 서명의 공간을 차지하지 않아도 된다는 장점이 있다. 정적 표본추출기는 D3D12_STATIC_SAMPLER_DESC 구조체를 통해 서술한다. 이 구조체는 D3D12_SAMPLER_DESC과 비슷하지만 몇 가지의 차이점이 있다. 우선 테두리 색상 설정을 3가지만 할 수 있다. 또한 셰이더 레지스터, 레지스터 공간, 셰이더 가시성을 지정하는 추가적인 필드들이 있다.
정적 표본추출기는 최대 2032개만 만들 수 있다. 만약 더 필요하다면 표본추출기 힙을 사용해야 한다.

이 책의 예제들은 정적 표본추출기 6개를 미리 만들어놓는다. 사용하지 않는다고 해서 큰 문제가 되지는 않기 때문이다. 정적 표본추출기들의 배열은 루트 서명 서술자의 멤버로 전달한다.

## 9.8 셰이더에서 텍스처 표본 추출

셰이더에서 특정한 레지스터에 대응된 텍스처 자원을 불러오기 위해서는 t 레지스터를 사용하며 표본추출기는 s 레지스터를 사용한다.

픽셀 셰이더에서 한 픽셀의 텍스처 좌표가 주어졌을 때 텍스처의 Sample 메서드를 통해서 텍스처를 추출할 수 있으며, 호출시에 표본추출기 객체를 넘겨주어야 한다. 그러면 SamplerState 객체로 지정된 필터링을 거쳐서 최종 색상을 반환한다.

## 9.9 나무 상자 예제

### 9.9.1 텍스처 좌표의 지정

GeometryGenerator 클래스의 CreateBox 메서드는 입방체의 면마다 텍스처 이미지가 잘 입혀지도록 텍스처 좌표를 적절히 설정한다.

이전에는 상자를 만들기 위해 총 8개의 정점만 필요했지만, 이는 여러 면의 법선, 텍스처 좌표를 하나의 정점에 설정하므로 부정확하다. 따라서 각 면마다 4개의 정점을 할당하여 총 24개의 정점을 사용하게 된다.

### 9.9.2 텍스처 생성

응용 프로그램이 사용하는 모든 텍스처를 unordered_map형인 mTextures에 담는다. 실무에서는 텍스처를 로딩하기 전에 이미 로딩을 하지는 않았는지를 검사하여 중복 로딩이 일어나지 않도록 해야 할 것이다.

### 9.9.3 텍스처 설정

SRV 힙과 서술자를 만들었다면 루트 서명에 넘겨주면 된다.

### 9.9.4 갱신된 HLSL

텍스처를 적용하기 위한 코드이다.

## 9.10 텍스처 변환

앞의 셰이더 코드에는 아직 설명하지 않은 상수버퍼의 gTexTransform과 gMatTransform이 등장한다. 텍스처 좌표는 평면의 2차원 점이므로, 다른 정점처럼 이동, 회전, 비례 변환을 적용할 수 있다. 예를 들면, 큰 벽에 벽돌 텍스처를 입힐 때 텍스처 좌표를 4배로 만들어 타일링을 할 수 있다. 또는 사각형으로 된 하늘 전체에 구름 텍스처를 입혔을 때 시간에 따른 이동 변환을 통해 구름이 흘러가도록 할 수 있다. 마지막으로 화염구가 날아갈 때 텍스처를 회전시켜 효과를 줄 수 있다.

변환 행렬은 물체별과 재질별로 나누어진다. 물이 전체적으로 이동해야 하는 경우에는 재질별 변환 행렬을 바꾸고, 물체별로 텍스처를 다르게 적용해야 할 때는 물체별 텍스처 변환 행렬을 바꾼다. 텍스처 변환에서 z성분을 바꾸는 것은 아무 영항을 주지 않는다.
