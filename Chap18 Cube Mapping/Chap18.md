# Chapter 18 Cube Mapping

## 목표

1. 입방체 맵이 무엇이고 HLSL 코드에서 어떻게 입방체 맵의 표본을 추출하는지 배운다.
2. DirectX 텍스처 도구들을 이용해서 입방체 맵을 생성하는 방법을 파악한다.
3. 입방체 맵으로 반사를 흉내내는 방법을 살펴본다.
4. 입방체 맵을 구에 입혀서 하늘과 멀리 있는 산들을 묘사하는 방법을 이해한다.

## 18.1 입방체 매핑

입방체 매핑(Cube Mapping)이란 정육면체 형태의 텍스처이다. 큐브의 각 면은 각 좌표축 방향에 대응되며, 각각을 +X, +Y, +Z, -X, -Y, -Z로 부른다. D3D에서 큐브 맵은 원소가 6개인 텍스처 배열이며, 각 인덱스는 순서대로 +X, -X, +Y, -Y, +Z, -Z에 대응된다.

큐브 맵의 한 텍셀을 추출하기 위해서 3차원 좌표를 이용한다. 큐브가 원점을 감싸고 있을 때, 3차원 룩업(lookup) 벡터를 방향 벡터로 하는 반직선이 큐브의 한 면과 만나는 지점이 추출된 텍셀이다.
HLSL에서는 큐브 맵을 TextureCube 형식으로 나타낸다.

## 18.2 환경 매핑

큐브 맵의 주 용도는 환경 매핑(environment mapping)이다. 환경 매핑은 수직, 수평 시야각이 모두 90도인 카메라를 각 좌표축의 양, 음 방향으로 향한 상태에서 렌더링해 총 6장의 이미지를 큐브 맵 형태로 담은 것을 의미한다. 이 6장의 이미지는 어떤 물체에서 본 주변 환경 전체를 담게 된다.

환경 매핑을 적용할 물체마다 환경 맵을 따로 만들어야 정확한 표현을 할 수 있지만, 그러면 메모리 부담이 커지게 된다. 그래서 주요 지점에서만 환경 맵을 만들어놓고 여러 개의 물체에 재활용하여 타협을 할 수 있다. 굴곡이 있는 물체가 주변을 덜 정확하게 반사하더라도 알아채기 쉽지 않기 때문에 실전에서도 응용하는 것이 가능하다.

또 하나의 최적화 기법은 환경 맵 이미지를 만들 때 장면의 일부 물체를 생략하는 것이다. 불완전하지만 단순히 주변의 반사를 표현하는 데에는 충분하다고 할 수 있다.

큐브 맵은 texassemble 프로그램을 이용하거나 온라인 상에서 프로그램을 구할 수 있다.

### 18.2.1 입방체 맵의 적재와 적용

DDS 형태로 저장된 텍스처라면 자동으로 큐브 맵을 인식해서 로딩을 할 수 있다. 그동안 사용해왔던 함수를 똑같이 사용하면 된다.

큐브 맵에 대한 SRV를 생성할 때는 ViewDimension을 D3D12_SRV_DIMENSION_TEXTURECUBE로 지정해야 한다.

## 18.3 하늘에 텍스처 입히기

환경 맵의 한 가지 용도는 하늘에 텍스처를 입히는 것이다. 지평선 멀리에 있는 산과 하늘의 모습을 묘사하기 위해 환경 맵을 이용해서 텍스처를 입힌다.

여기서는 하늘 구가 무한히 멀리 있다고 가정한다. 따라서 카메라가 어느 방향으로 움직이든 구와의 거리는 변하지 않아야 한다. 이것을 구현하는 방법은 세계 공간에서 하늘 구의 중심을 항상 카메라의 중심과 동일하도록 하면 된다.

하늘은 항상 NDC 상에서 z가 1이 되도록 해야 한다. 따라서 동차 절단 공간에서 z=w로 설정하여 동차 나누기를 수행했을 때 z가 1이 되도록 한다.
또한 구의 내부를 렌더링하는 과정이므로 후면 선별을 비활성화하거나 삼각형 감김 방향을 반시계로 설정해야 한다. 또한 깊이 판정을 LESS가 아닌 LESS_EQUAL로 해야 한다.

## 18.4 물체의 주변 환경 반사

주변 환경이 물체에 비치는 것을 시뮬레이션한다. 이론상 환경 구가 무한히 멀리 있으므로 메시 상의 한 점이 어디에 있는지는 중요하지 않고, 법선 벡터에 대해서 시선 벡터를 반사한 결과를 환경 맵의 조회 벡터로 사용하면 된다. 즉 해당 메시 상의 점으로 환경 맵에서 발사되는 빛을 계산하는 것이다. 반사는 프레넬 효과에 의해 결정되고, 최종 색상에 더한다.

만약 환경 구가 무한히 멀리 있지 않다면 반사 벡터의 방향 뿐만 아니라 시작점까지도 영향을 미칠 수 있다. 따라서 반직선을 그어서 정확한 조회 벡터를 선택해야 할 것이다.

## 18.5 동적 입방체 맵

앞서 사용한 큐브 맵은 정적(static)인 방식으로, 비용이 싸지만 주변 사물들의 움직임을 반영하지는 못한다.

그러므로 매 프레임마다 투영하고자 하는 위치에서 주변 사물들을 렌더링하여 큐브 맵을 갱신하여 사용한다면 물체에 비친 주변 사물의 모습을 표현할 수 있게 된다.

### 18.5.1 동적 입방체 맵 보조 클래스

큐브 맵을 생성하기 위해 SRV 1개, RTV 6개가 필요하다. RTV는 큐브 맵에 씬을 렌더링할 때 사용하고, SRV는 셰이더에서 큐브 맵에 접근할 때 필요하다.

### 18.5.2 입방체 맵 자원 생성

렌더 타겟을 허용해주어야 한다.

### 18.5.3 추가 서술자 힙 공간

RTV가 6개, SRV가 1개 더 들어갈 공간을 힙에 마련해야 한다.

### 18.5.4 서술자 구축

SRV 1개, RTV 6개를 생성한다.

### 18.5.5 깊이 버퍼 구축

한 면을 한 번씩 렌더링한 후 깊이 버퍼를 초기화하면 되므로 깊이 버퍼는 1개만 있으면 충분하다.

### 18.5.6 입방체 맵 뷰포트와 가위 직사각형

메인 카메라의 것과는 다르므로 따로 정의해준다. 큐브 맵 렌더링 시에 뷰포트와 가위 직사각형을 변경한 다음 원래대로 되돌려야 한다.

### 18.5.7 입방체 맵 카메라 설정

aspect(종횡비) = 1, 수직 시야각 = 90도로 설정한다.

각 면에 대해서 렌더링을 할 때 view matrix를 변경해주어야 하므로, PassConstant를 총 7개(메인 카메라 1개+각 면의 카메라 6개) 생성하여 각 카메라에 대응시키는 것으로 한다.

복습: 순간적으로 PassConstant를 2개만 생성한 다음 렌더링 도중에 값을 변경해주면 안될까 생각했다. 이것은 불가능한 것이, C++ 코드 상에서 렌더링 관련 함수들을 호출해도 그 시점에 실제로 렌더링이 이루어지는 것이 아니라, 단순히 command list에 명령을 추가하는 것일 뿐이다. 실제 렌더링은 command list를 제출한 다음에 진행되므로, PassConstant를 7개 마련해놓고 특정 시점에 다른 PassConstant를 cbuffer 레지스터에 대응시켜야 한다.

### 18.5.8 장면을 입방체 맵에 그리기

큐브 맵을 작성할 때는 맵을 투영할 구 자신은 렌더링하면 안된다.

이후에는 다른 물체들을 렌더링한 후, 환경 맵을 렌더링한 큐브 맵으로 변경한 다음 구를 렌더링해주면 된다.

## 18.6 기하 셰이더를 이용한 동적 입방체 매핑

기하 셰이더를 사용해서 drawcall 한 번에 6개의 면에 모두 물체를 렌더링하는 것이 가능하다.

이 기법의 핵심은 각 면의 카메라에 대한 view matrix, 깊이 버퍼, 렌더 타겟을 배열 형태로 모두 받아놓은 다음, 기하 셰이더를 이용해서 들어온 삼각형을 6개로 복제하여 각 면에서의 view space로 변환하는 것이다. 이때, 한 면에만 삼각형을 렌더링하기 위해 기하 셰이더의 시스템 값 SV_RenderTargetArrayIndex를 변경하여 특정한 렌더 타겟에만 전달할 수 있다.

책에서는 이 기법이 기하 셰이더를 통해 대량의 데이터를 출력하고, 하나의 삼각형이 큐브 맵의 하나의 면에서만 보이지만 기하 셰이더에서 Frustum Culling을 적용시키기 어려워 비효율적이지만, 지속적으로 변하는 배경을 렌더링할 때는 효과적일 것이라고 말한다.
