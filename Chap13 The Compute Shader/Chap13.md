# Chap13 컴퓨트 셰이더

GPU는 병렬 연산에 최적화되어 있다. GPU는 당연히 그래픽 연산에 최적화되어 있지만, 그 외의 특정 분야에서 강점을 보일 수 있다. 이를 GP(General Purpose)GPU라고 한다. GPU를 효율적으로 활용하려면 알고리즘에 데이터 병렬성(data parallelism)이 있어야 한다. 대표적으로 파도 예제에서 각 격자 요소를 계산하는 것이 있다.

GPGPU 프로그래밍에서는 GPU의 계산 결과를 CPU에서 읽어야 하는 경우가 많으며, 여기서 병목이 생기는 경우가 많다. 하지만 그래픽에서는 GPU에서의 계산 결과를 렌더링 파이프라인의 입력으로 사용하므로 데이터를 CPU로 전송할 필요가 없다. 예를 들면 계산 셰이더에서 텍스처를 흐린(blur) 다음 흐려진 텍스처에 대한 SRV를 다른 셰이더의 입력에 묶는 것이 가능하다.

계산 셰이더는 D3D가 제공하는 프로그램 가능 셰이더의 하나로, 렌더링 파이프라인에 직접 포함되지는 않는다. 계산 셰이더는 파이프라인의 옆에 따로 존재하며 GPU의 자원을 직접 읽거나 쓸 수 있다. 계산 셰이더는 그리기 연산을 호출하지 않아도 GPU에 접근할 수 있게 해주는 수단이다. 계산 셰이더는 GPGPU 프로그래밍에 유용하지만 계산 셰이더로 구현할 수 있는 그래픽 효과들도 많이 있으므로 그래픽에서도 중요하다. 계산 셰이더는 D3D의 일부이고 자원들을 읽거나 쓸 수 있으므로 계산 셰이더의 출력을 렌더링 파이프라인에 묶는 것이 가능하다.

## 목표

1. 계산 셰이더의 프로그래밍 방법을 배운다.
2. 하드웨어가 스레드 그룹 및 그룹 안의 스레드들을 처리하는 방법을 개괄적으로 이해한다.
3. 계산 셰이더의 입력으로 설정할 수 있는 D3D 자원의 종류와 계산 셰이더의 출력으로 설정할 수 있는 D3D 자원의 종류를 파악한다.
4. 여러 종류의 스레드 ID와 그 용도를 이해한다.
5. 공유 메모리가 무엇이고 성능 최적화에 어떻게 활용하는지 배운다.
6. GPGPU 프로그래밍에 대한 좀 더 자세한 정보를 얻을 수 있는 곳들을 살펴본다.

## 13.1 스레드와 스레드 그룹

### GTX 1060 스펙

CUDA 1280개, Multiprocessor 10개
Pascal 아키텍처에서는 multiprocessor당 CUDA 코어가 128개이다.

GPU 프로그래밍에서는 작업을 실행할 다수의 스레드를 스레드 그룹들로 묶고, 그러한 스레드 그룹들로 하나의 격자(grid)를 형성한다. 하나의 스레드 그룹은 하나의 다중처리기(multiprocessor)에서 처리한다. 예를 들어 사용하는 GPU의 다중처리기가 16개라면 문제를 적어도 16개의 스레드 그룹으로 나누어야 모든 다중처리기에 작업을 나누어 줄 수 있다. 그리고 더 나은 성능을 위해서는 다중처리기 당 적어도 2개의 스레드 그룹을 두는 것이 바람직하다. 왜냐하면 다중처리기는 정체(stall) 현상을 숨기기 위해 다른 그룹의 스레드들로 처리를 전환하는 능력을 갖추고 있기 때문이다.

각 스레드 그룹에는 그룹의 모든 스레드가 접근할 수 있는 공유 메모리가 주어진다. 스레드들은 자신이 속한 그룹이 아닌 다른 그룹의 공유 메모리에는 접근하지 못한다. 한 그룹 내에서는 스레드 동기화 연산이 가능하지만, 서로 다른 그룹들끼리는 작동 순서를 바꿀 수 없다.

하나의 스레드 그룹은 다수의 스레드로 이루어진다. NVIDIA에서는 하나의 스레드 덩어리를 워프(warp)라는 단위로 묶으며 여기에는 32개의 스레드가 들어있다(Fermi 아키텍처). AMD에서는 웨이브프런트 단위를 사용하며 64개의 스레드로 이루어져 있다. 성능을 위해서는 이들의 배수로 스레드 그룹 개수를 설정하는 것이 바람직하다.

일단은 스레드 그룹 크기를 256으로 설정한다. 이 숫자는 다양한 하드웨어에 적합한 숫자이다. 스레드 그룹의 스레드 개수를 변경하면 배분(dispatch)되는 그룹들의 개수가 변한다.

D3D에서 스레드 그룹들을 실행할 때 사용하는 메서드는 command list의 Dispatch이다.

Dispatch 메서드를 실행할 때는 최대 3차원 격자 형태로 구성할 수 있다. 이 책에서는 2차원까지만 사용하며, Z 성분은 1로 설정한다.

## 13.2 간단한 계산 셰이더 예제

하나의 계산 셰이더는 다음과 같은 요소들로 구성된다.

1. 상수 버퍼들을 통한 전역 변수 접근
2. 입력 자원과 출력 자원(13.3에서 자세히 다룸)
3. 스레드 그룹의 구성과 스레드 개수를 지정하는 numthreads 속성
4. 각 스레드에서 실행할 명령들을 담은 계산 셰이더 함수 본문.
5. 스레드 식별을 위한 시스템 값 semantic 매개변수(13.4)
   numthreads 특성을 이용하면 다양한 스레드 그룹 위상구조(topology)를 만들 수 있다. 예를 들어 하나의 행으로 배치된 스레드 그룹을 원한다면 numthreads(X, 1, 1) 형태를 사용하면 된다. 어떤 topology를 사용할지는 풀고자 하는 문제에 따라 결정해야 한다. 주의할 점은 앞서 언급한대로 총 스레드 개수가 워프 또는 웨이브프런트 개수의 배수이어야 한다는 것이다.

### 13.2.1 계산 셰이더 설정

계산 셰이더는 계산 PSO를 이용하여 활성화하며, 계산 PSO 서술 구조체인 D3D12_COMPUTE_PIPELINE_STATE_DESC를 사용한다. 계산 PSO는 그래픽 PSO에 비해서 단순하다.

## 13.3 자료 입력 자원과 출력 자원

계산 셰이더에서 활용할 수 있는 자원은 버퍼와 텍스처 두 가지이다.

### 13.3.1 텍스처 입력

텍스처 자원을 HLSL 내에서 정의한 다음 SRV와 루트 매개변수를 통해 계산 셰이더에 전달한다. SRV는 읽기 전용이다.

### 13.3.2 텍스처 출력과 순서 없는 접근 뷰(UAV)

출력 자원은 특별하게 취급되며, 자원 형식의 이름 앞에 RW(Read-Write)를 붙여야 한다. 또한 해당 자원에 담을 자료의 형식을 템플릿(<>) 형태로 명시한다. 예를 들어 부동소수점 색상을 담는 출력 텍스처 자원은 RWTexture2D\<float4\>이다.

출력 자원을 계산 셰이더에 묶는 것은 입력 자원의 SRV와는 달리 UAV(Unordered Access View)를 통해 가능하다. 일단 텍스처 자원을 생성할(CreateCommittedResource) 때 Flags에 D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS를 지정한다. 그 다음 뷰를 생성하는데, 하나의 텍스처 자원은 UAV와 SRV 둘 다로 묶는 것이 가능하다. 단, 동시에 묶지는 않는다. UAV를 통해 계산 셰이더가 텍스처 자원에 결과를 기록하고, SRV를 통해 특정 기하구조에 입히는 것이 가능하다.

CBV, SRV, UAV는 같은 종류의 힙에 담는 것이 가능하다. 계산 셰이더를 위한 UAV 서술자들을 힙에 넣었다면 Dispatch 명령을 추가하기 전에 루트 매개변수를 통해 UAV를 전달하면 된다.

### 13.3.3 텍스처 색인화 및 표본 추출

계산 셰이더는 GPU에서 실행되므로 GPU의 기능들을 사용할 수 있다. 다만 몇 가지 주의할 점이 있다. 첫 번째로 Sample 대신 SampleLevel을 사용하는 것이다. 계산 셰이더에서는 밉맵 수준을 판단하는 것이 불가능하기 때문에 밉맵 수준을 자동으로 선택하는 Sample을 사용하면 안 되고 수동으로 밉맵 수준을 지정하는 SampleLevel 메서드를 사용한다. 두 번째는 텍스처를 추출할 때 텍스처 좌표를 [0, 1] 구간으로 지정해야 하는 것이다. 이는 정수 인덱스 (x, y)를 각각 너비와 높이로 나누어 주면 된다.

결론은 텍스처 자원으로부터 요소를 조회할 때 [ ] 연산자를 활용하려면 int2를 전달해야 하고, SampleLevel을 사용하려면 [0, 1] 범위의 float2를 전달해야 하는 것이다. 자료를 수정할 때는 반드시 [ ] 연산자를 사용해야 한다.

### 13.3.4 구조적 버퍼 자원

구조적 버퍼(Structured buffer)는 같은 형식의 원소들을 담는 버퍼로, 하나의 배열이라고 볼 수 있다.

SRV로 쓰이는 구조적 버퍼나 UAV로 쓰이는 구조적 버퍼는 정점 버퍼나 색인 버퍼를 생성하는 것과 거의 비슷하나, 플래그를 적절하게 지정해주어야 한다는 차이점이 있다.

구조적 버퍼를 파이프라인에 묶는 방법은 기존과 동일하다. SRV와 UAV를 생성해서 루트 매개변수에 전달하는 것이다. 다만 텍스처는 반드시 서술자 테이블을 사용해야 하는 것과는 다르게 루트 서술자를 통해 전달할 수도 있다는 차이점이 있다.

참고: Raw 버퍼라는 것도 있다. 이 버퍼는 임의의 자료들을 담는 배열이다. 서로 다른 자료형의 값들을 넣은 다음 적절한 캐스팅을 통해 값을 뽑아낼 수 있다. Raw 버퍼는 자원 형식을 TYPELESS로 지정해야 하며, Flag를 RAW로 지정해야 한다. 이 책에서는 사용하지 않는다.

### 13.3.5 계산 셰이더의 결과를 시스템 메모리에 복사

텍스처 처리에 계산 셰이더를 활용할 경우 처리를 마친 텍스처를 기하구조에 입혀서 화면에 표시하는 것이 일반적이다. 이러한 경우에는 계산 셰이더의 결과를 눈으로 확인하는 것이 가능하다. 그러나 구조적 버퍼를 사용하는 경우에는, 그리고 일반적인 GPGPU 프로그래밍에서는 계산 셰이더의 결과를 화면에 표시하지 않는다. 그러므로 계산 셰이더의 결과를 확인하려면 GPU 메모리의 자료를 CPU 메모리쪽으로 복사해야 한다. 그러려면 힙 속성이 READBACK인 시스템 메모리 버퍼를 생성해야 한다. Command list의 CopyResource 메서드를 이용하여 출력 버퍼의 데이터를 readback 버퍼에 복사한 다음, Map을 통해 CPU 메모리쪽으로 읽어오면 된다.

이번 장의 한 예제인 VecAdd의 경우 총 32개의 Data 구조체의 원소들을 각각 더하는 연산을 계산 셰이더를 이용하여 수행한 다음 CPU 메모리쪽으로 읽어와서 파일 형태로 출력한다.

## 13.4 스레드 식별 시스템 값(System Value)

1. 각 스레드 그룹에 고유한 ID가 배정된다. 이를 그룹 ID라고 한다. 이에 해당하는 semantic은 SV_GroupID이다. (G_x, G_y, G_z)개의 그룹들로 dispatch한다면 범위는 (0, 0, 0)부터 (G_x-1, G_y-1, G_z-1)이다.
2. 한 스레드 그룹 내에서 각 스레드마다 배정되는 고유한 ID이다. 이를 그룹 스레드 ID라고 한다. 스레드 그룹 크기가 (X, Y, Z)라면 범위는 (0, 0, 0)부터 (X-1, Y-1, Z-1)이다. 대응되는 semantic은 SV_GroupThreadID이다.
3. Dispatch를 호출하면 스레드 그룹들이 격자 형태로 배치된다. 격자 전체에서 각 스레드를 구분하는 ID가 배분 스레드 ID(dispatch thread ID)이다. Semantic은 SV_DispatchThreadID이다.
4. 그룹 스레드 ID의 선형 버전을 SV_GroupIndex semantic을 통해 전달한다.
   다양한 종류의 스레드 ID들을 통해 자료에 접근할 때 인덱싱을 수월하게 할 수 있다.

## 13.5 추가 버퍼와 소비 버퍼

서로 상호작용하지 않는 동시에 순서 배치가 크게 중요하지 않은 자료의 경우에는 소비 버퍼(consume buffer)와 추가 버퍼(append buffer)가 유용하다. 이들을 이용하면 인덱싱을 하지 않아도 되기 때문이다.

소비 버퍼는 각 원소를 순서 상관없이 한 번씩 내보내는 버퍼이다. ConsumeStructuredBuffer를 통해 정의하며, Consume 메서드를 사용해서 원소 하나를 얻어낼 수 있다.

추가 버퍼는 AppendStructuredBuffer로 만들 수 있다. 추가 버퍼는 동적으로 늘어나지는 않으므로 추가하는 모든 원소를 담을 수 있는 크기로 만들어야 한다. 입력 버퍼와 출력 버퍼의 원소들의 순서는 아무 상관이 없다.

## 13.6 공유 메모리와 동기화

각 스레드 그룹에는 공유 메모리(shared memory) 또는 스레드 지역 저장소(thread local storage)라고 부르는 공간이 주어진다. 접근 속도가 빠르기 때문에 이 공간을 일종의 캐시라고 생각해도 된다. 계산 셰이더에서 공유 메모리를 선언하려면 groupshared 키워드를 앞에 붙이면 된다. 공유 메모리의 크기는 그룹 공유 메모리 크기의 상한인 32KB를 넘지 않는 한에서 임의로 설정할 수 있다. 공유 메모리는 각 그룹별로 배정되므로 그룹 스레드 ID를 이용해 각 스레드에 공유 메모리를 배정해주는 식으로 활용할 수 있다.

공유 메모리를 너무 많이 사용하면 성능 문제가 생길 수 있다. 예를 들어 멀티프로세서 하나가 32KB의 공유 메모리를 지원하는 어떤 시스템에서 20KB의 공유 메모리를 사용하는 계산 셰이더를 실행한다고 하자. 그러면 멀티프로세서 하나로 돌릴 수 있는 스레드 그룹은 하나이다. 2개를 돌리는 순간 최대 지원 공유 메모리를 초과하므로 불가능한 것이다. 멀티프로세서가 스레드 그룹을 하나만 지원하면 stall 현상을 숨기기 위한 스레드 그룹 전환이 불가능해지므로 GPU의 병렬성이 낮아진다(앞에서 멀티프로세서 하나당 적어도 2개의 스레드 그룹을 두는 것을 권장한다고 언급함).

공유 메모리의 용도 중 하나는 텍스처 값을 저장하는 것이다. 흐리기 같은 알고리즘은 동일한 텍스처를 여러 번 추출해야 한다. 이는 GPU 메모리에 여러 번 접근해야 하는 것인데, 여기서 병목이 발생할 수 있고, 추출한 데이터를 공유 메모리에 저장하고 재사용한다면 병목을 줄여서 성능을 향상시킬 수 있을 것이다. 여기서 주의할 점이 있는데, 스레드 그룹의 모든 스레드가 동시에 작업을 진행한다는 보장이 없다는 것이다.

계산 셰이더에서 텍스처의 표본을 추출해 공유 메모리에 저장한 다음, 자신의 영역과 양 옆 스레드의 영역에 들어있는 값들의 합을 구한다고 해보자. 자신의 자리에 있는 값은 당연히 계산이 완료된 상태이지만, 양 옆의 스레드는 표본 추출 작업을 완료했는지 알 수 없다. 그러므로 모든 스레드가 작업을 완료할 때까지 기다린 다음에 그 다음 작업을 수행해야 한다. 이를 위해 동기화 함수를 호출한다.

## 13.7 흐리기 예제

이번 절에서는 계산 셰이더를 이용하여 흐리기(blurring) 알고리즘을 구현한다. 일단 흐리기의 수학적인 서술을 알아본 다음 흐리기를 적용할 원본 이미지를 생성하는데 쓰이는 render-to-texture 기법을 논의한다.

### 13.7.1 흐리기 이론

흐리기 알고리즘을 일반적으로 표현하면 다음과 같다. 원본 이미지의 각 픽셀에 대해서 그 픽셀을 중심으로 한 특정한 직사각형 내에 속한 픽셀들의 가중 평균을 구하여 그 픽셀의 결과값으로 정하는 것이다. 직사각형의 가로, 세로 길이가 홀수라면 중심이 명확하게 정해질 것이다. 격자의 크기를 mXn이라고 하고, m=2a+1, n=2b+1이라고 정의하면 a를 수직 흐리기 반지름, b를 수평 흐리기 반지름이라고 한다. a=b일때는 수평, 수직을 구분하지 않고 흐리기 반지름이라고 한다. mXn 가중치 행렬을 흐리기의 핵(kernel)이라고 한다. 가중치들의 합을 1이 되어야 한다. 1보다 작다면 이미지가 어두워지고, 1보다 크면 밝아진다.

합이 1인 가중치들을 결정하는 방법은 다양한데, 여기서는 가우스 흐리기를 사용한다. 가우스 흐리기는 가우스 함수 $G(x)=exp⁡(-x^2/(2{\sigma}^2 )) \ or \ G(x,y)=exp⁡(-(x^2+y^2)/(2{\sigma}^2 ))$를 가중치로 사용한다.

가우스 흐리기의 경우 분리 가능(seperable)하다. 분리 가능이란 2차원을 대상으로 하는 연산을 1차원 2번으로 해도 같은 결과가 도출된다는 것이다.

만약 흐리기를 9X9에 대하여 한다고 하면 일반적으로는 총 81개의 항을 더해야 한다. 하지만 가우스 흐리기는 분리 가능하므로 가로 흐리기를 한 번 수행한 결과에 세로 흐리기를 수행하면 동일한 결과를 얻을 수 있다.

### 13.7.2 텍스처 대상 렌더링 기법

렌더 타겟이 후면 버퍼가 아닌 화면 밖(off-screen)의 텍스처인 경우 render-to-off-screen-texture, 줄여서 텍스처 대상 렌더링(render-to-texture)라고 한다. 이 경우에는 렌더링 결과가 화면에 표시되지 않는다.

텍스처 대상 렌더링은 다양한 특수 효과 구현에 쓰인다. 예를 들면 장면의 조감도(높은 곳에서 내려다본 모습)을 하나의 텍스처에 렌더링하고, 후면 버퍼에 렌더링을 수행할 때 화면 오른쪽 아래 모퉁이의 작은 사각형에 입혀 미니맵을 흉내낼 수 있다. 이외의 용도에는 그림자 매핑, SSAO, 입방체 맵을 이용한 동적 반사 등이 있다.

이번 장의 흐리기 예제는 텍스처 대상 렌더링 기법을 이용해서 흐리기 알고리즘을 GPU에서 수행한다. 방법은 다음과 같다.

1. 장면을 화면 밖 텍스처에 그린다.
2. 화면 밖 텍스처를 계산 셰이더 프로그램을 이용해서 그린다.
3. 후면 버퍼를 다시 렌더 대상으로 설정하고, 흐려진 텍스처를 화면 전체 크기의 사각형에 입힌다.
   이번 장의 예제에서는 위의 방법은 사용하지 않고, 기존처럼 후면 버퍼를 대상으로 렌더링을 한 다음 외부 텍스처에 후면 버퍼의 내용을 그대로 복사한 다음 처리하는 방법을 사용한다. 텍스처 대상 렌더링을 이용하는 것은 연습문제 6에서 구현한다.

참고: 렌더링 파이프라인과 계산 셰이더는 서로 다른 context에서 이루어지므로 context 전환이 필요하다. 전환에는 추가 비용이 필요하기 때문에 전환 횟수를 최소화하는 것이 바람직하다.

### 13.7.3 흐리기 구현의 개요

2차원 흐리기가 분리 가능하므로 수직 흐리기, 수평 흐리기를 나눠서 계산한다. 흐리기를 구현하려면 텍스처가 2개 필요하며, 둘 다 읽기와 쓰기 모두 가능해야 한다. 처음 상태의 이미지가 들어있는 텍스처를 A, 같은 크기의 다른 텍스처를 B라고 하자. 일단 A와 B의 SRV, UAV를 생성한다. 흐리기 알고리즘의 흐름은 다음과 같다.

1. A에 대한 SRV를 계산 셰이더의 입력으로, B에 대한 UAV를 출력으로 설정한다.
2. 수평 흐리기 연산을 수행한다. 결과는 B에 저장한다.
3. B에 대한 SRV를 계산 셰이더의 입력으로, A에 대한 UAV를 출력으로 설정한다.
4. 수직 흐리기 연산을 수행한다. 결과는 A에 저장되며, 이것이 한 번 흐리기를 한 것이다.
   위의 과정을 여러 번 반복하면 이미지를 더 흐릴 수 있다.
   창의 크기가 변할 때 각 텍스처의 크기를 변경해야 한다. 이는 OnResize 함수에서 처리할 것이다.
   구현을 위해 BlurFilter라는 클래스를 작성한다. 명세는 다음과 같다.
5. BlurFilter: 생성자. 흐릴 대상의 크기와 형식을 전달한다.
6. ID3D12Resource\* Output(): 흐린 결과가 들어있는 텍스처 자원의 포인터를 반환한다.
7. BuildDescriptors(CPU_DESCRIPTOR_HANDLE, GPU_DESCRIPTOR_HANDLE, descriptorsize): 사용하기 위해서 한 번은 호출해야 하며, 이 함수를 통해 서술자 힙의 어느 위치에 흐리기에서 사용할 텍스처의 서술자를 저장할지를 전달한다. BlurFilter에서는 총 텍스처 2개를 사용하며 각각의 SRV, UAV를 생성할 것이므로 총 4개의 서술자를 채울 것이다.
8. OnResize(width, height): 화면 크기가 변경되었을 때 호출되며, 텍스처 리소스를 다시 생성하고 그에 대한 서술자들도 재생성해야 한다.
9. Execute(cmdlist, rootSig, horzBlurPSO, vertBlurPSO, input, blurCount): 흐리기를 실행한다.

### 13.7.4 계산 셰이더 프로그램

수평 흐리기 계산 셰이더, 수직 흐리기 계산 셰이더를 순서대로 실행한다. 두 과정은 사실상 동일하므로 수평 흐리기에 대한 구현만 논의한다.

수평 흐리기에서 스레드 그룹의 크기는 256x1x1이다. 하나의 스레드가 하나의 픽셀을 흐린다.

흐리기를 진행할 때 텍스처의 동일한 부분을 여러 번 추출하게 된다. 텍스처 표본 추출을 매번 하는 것보다는 공유 메모리에 텍스처 추출 결과를 저장한 다음 여러 번 불러오면 최적화를 할 수 있다.

공유 메모리를 이용해 흐리기를 구현할 때 주의할 점은 한 스레드 그룹에서 불러오는 텍셀의 수가 n(=256)이 아닌 n+2R(R=흐리기 반지름)이라는 것이다. 따라서 공유 메모리의 원소 개수는 n+2R이 된다. 텍셀을 불러올 때는 각자 자신이 해당하는 부분의 픽셀을 불러오되, 왼쪽의 R개 텍셀은 왼쪽 R개의 스레드가, 오른쪽 R개 텍셀은 오른쪽 R개 스레드가 각각 하나씩 추가로 불러오도록 설계한다.

여기서 발생하는 문제점은 범위 밖의 텍셀을 읽을 수 있다는 것이다. 예를 들어 텍스처 전체의 가장 왼쪽 텍셀을 흐리는 스레드의 경우 범위 밖의 텍셀에 접근하게 된다. 범위 밖의 텍셀을 읽을 경우 자동으로 0을 돌려주므로 작동하기는 하나, 흐리기 연산 시에 검은색이 들어가게 되므로 가장자리가 어두워진다. 그러므로 텍스처 좌표의 clamp 모드처럼 범위 밖의 텍셀에 대해서는 가장 가까운 범위 내의 텍셀 값을 돌려주도록 한다. 이는 min, max 함수를 이용하면 된다.

자신의 위치에 있는 텍셀을 불러올 때에는 0보다 작은 위치에 접근할 일은 절대 없지만, 텍스처의 크기보다 큰 곳에 접근할 가능성이 있다. 그러므로 min을 이용해서 범위를 한정한다.

텍스처 범위 밖의 스레드가 기록을 하는 것은 자동으로 무연산(no-op)으로 처리되기 때문에 신경쓰지 않아도 된다.
